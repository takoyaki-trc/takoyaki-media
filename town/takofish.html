<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>たこ焼き釣り｜焼かれた伝説</title>
  <meta name="description" content="たこ焼き釣りミニゲーム（最高記録保存 / 結果に日時表示）" />
  <style>
    :root{
      --bg0:#07060b;
      --bg1:#0c1025;
      --panel: rgba(255,255,255,.07);
      --line: rgba(255,255,255,.14);
      --text:#fff;
      --muted:rgba(255,255,255,.75);
      --btn: rgba(255,255,255,.10);
      --btn2: rgba(255,255,255,.16);
      --shadow: 0 14px 40px rgba(0,0,0,.55);
      --radius: 16px;
      --cyan:#7fd0ff;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,"Noto Sans JP",sans-serif;
      color:var(--text);
      background:
        radial-gradient(circle at 50% 18%, #1a2040 0%, #070812 60%),
        linear-gradient(var(--bg0),var(--bg1));
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;
    }

    .app{ min-height:100svh; display:flex; flex-direction:column; }
    .topbar{
      position: sticky; top:0; z-index:50;
      padding: 10px 10px 8px;
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,0));
      backdrop-filter: blur(8px);
    }
    .topbar-inner{ max-width: 920px; margin:0 auto; display:flex; align-items:center; gap:10px; }
    .backbtn{
      appearance:none; border:1px solid var(--line);
      background: rgba(255,255,255,.08); color:var(--text);
      border-radius: 12px; padding: 10px 12px; font-weight: 900; cursor:pointer;
    }
    .titlebox{ min-width:0; display:flex; flex-direction:column; gap:2px; }
    .title{ font-weight:1000; letter-spacing:.02em; line-height:1.1; font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .subtitle{ font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .main{ flex:1; display:flex; justify-content:center; padding: 10px 10px calc(16px + env(safe-area-inset-bottom)); }
    .card{
      width: min(560px, 100%);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 0;
    }
    .hud{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      background: rgba(0,0,0,.12);
    }
    .hud-left{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: var(--btn);
      color:var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
    }
    .btn:hover{ background: var(--btn2); }
    .btn[disabled]{ opacity:.45; cursor:not-allowed; }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:12px; color: rgba(255,255,255,.9); }
    .stats b{ font-weight: 1000; }

    .canvaswrap{ position:relative; padding:10px; display:flex; flex-direction:column; gap:10px; min-height:0; flex:1; }
    .canvasbox{
      position:relative;
      width:100%;
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.14);
      background:#081425;
      flex: 1;
      min-height: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      touch-action: none;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      image-rendering: pixelated;
      touch-action: none;
    }
    .footnote{ font-size: 11px; color: rgba(255,255,255,.7); line-height: 1.5; }

    .overlay{
      position:absolute; inset:0;
      display:none; align-items:stretch; justify-content:center;
      background: rgba(0,0,0,.72);
      padding: 12px;
    }
    .overlay.show{ display:flex; }

    .panel{
      width: min(520px, 100%);
      background: #0b0f18;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 16px;
      overflow:hidden;
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      max-height: calc(100svh - 190px);
    }
    .panel-head{
      padding: 10px 12px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }
    .panel-head .h{ font-weight:1000; font-size:14px; letter-spacing:.02em; }
    .panel-body{
      padding: 12px;
      overflow:auto; min-height:0;
      font-size: 12px; line-height: 1.6;
      color: rgba(255,255,255,.92);
      background: rgba(0,0,0,.12);
    }
    .panel-foot{
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,.12);
      display:flex;
      gap:8px;
      background: rgba(0,0,0,.10);
      position: sticky;
      bottom: 0;
    }
    .panel-foot .btn{ flex:1; padding: 12px 12px; }
    .ghost{ background: transparent; }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .mini{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 10px;
    }
    .mini .k{ font-weight: 1000; margin-bottom: 6px; }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      font-weight: 900;
    }
    .iconimg{ width: 26px; height: 26px; image-rendering: pixelated; display:block; }
    .muted{ color: rgba(255,255,255,.72); }

    .resultMain{ font-weight:1000; font-size:18px; line-height:1.35; margin: 10px 0 8px; }
    .resultLines > div{ margin: 2px 0; }
    .tagNew{
      display:inline-block;
      font-size: 11px; font-weight: 1000;
      padding: 4px 8px; border-radius: 999px;
      background: rgba(127,208,255,.18);
      border: 1px solid rgba(127,208,255,.35);
      color: #dff3ff;
      margin-left: 8px;
      vertical-align: middle;
    }

    /* ===== ルール画面：海の中っぽい模様 ===== */
    .rulesSea{
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(40,160,255,.16), transparent 60%),
        radial-gradient(900px 700px at 80% 30%, rgba(0,255,210,.10), transparent 60%),
        radial-gradient(700px 600px at 40% 90%, rgba(120,90,255,.10), transparent 60%),
        repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,.06) 0 2px, transparent 2px 14px),
        linear-gradient(180deg, rgba(0,40,70,.55), rgba(0,10,25,.70));
    }

    /* ===== SP表示ブロック ===== */
    .spBox{
      margin-top: 12px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
    }
    .spImg{
      width: min(320px, 100%);
      aspect-ratio: 3 / 4;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      overflow:hidden;
      background: rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      margin: 8px auto 10px;
    }
    .spImg img{
      width:100%;
      height:100%;
      object-fit: cover;
      image-rendering: pixelated;
      display:block;
    }
    .spQ{
      text-align:center;
      font-weight: 1000;
      margin-top: 6px;
    }
    .spBtns{
      margin-top: 10px;
      display:flex;
      gap:10px;
    }
    .spBtns .btn{ flex:1; }
  </style>
</head>

<body>
  <div class="app">
    <header class="topbar">
      <div class="topbar-inner">
        <button id="backBtn" class="backbtn" type="button" aria-label="戻る">← 戻る</button>
        <div class="titlebox">
          <div class="title">たこ焼き釣り</div>
          <div class="subtitle">最高得点保存 / 結果に日時表示</div>
        </div>
      </div>
    </header>

    <main class="main">
      <section class="card" aria-label="たこ焼き釣り">
        <div class="hud">
          <div class="hud-left">
            <button id="retryBtn" class="btn" type="button">もう一回</button>
            <button id="rulesBtn" class="btn ghost" type="button">ルール</button>
          </div>
          <div class="stats" aria-label="ステータス">
            <span>スコア：<b id="tfScore">0</b></span>
            <span>残り：<b id="tfTime">--</b>s</span>
            <span>連続：<b id="tfCombo">0</b></span>
            <span>失敗：<b id="tfMiss">0</b></span>
            <span>最高：<b id="tfBest">0</b></span>
          </div>
        </div>

        <div class="canvaswrap">
          <div class="canvasbox">
            <canvas id="tfCanvas" width="360" height="520"></canvas>

            <!-- Rules Overlay -->
            <div id="rulesOverlay" class="overlay show" role="dialog" aria-modal="true" aria-label="ルール">
              <div class="panel">
                <div class="panel-head">
                  <div class="h">ルール（点数が分かりやすい版）</div>
                  <button id="rulesCloseX" class="btn ghost" type="button" aria-label="閉じる">×</button>
                </div>
                <div class="panel-body rulesSea">
                  <div class="muted" style="margin-bottom:10px;">
                    タップした場所に糸（ピック）を垂らして、たこ焼きに当てて釣り上げよう。<br>
                    天敵にぶつかると奪われる。生焼けはマイナス。
                  </div>

                  <div class="grid2">
                    <div class="mini">
                      <div class="k">サイズ（基本点）</div>
                      <div class="row" id="sizeRow"></div>
                      <div class="muted" style="margin-top:8px;">
                        ※小さいほど高い。巨大は途中で落ちることがある。
                      </div>
                    </div>

                    <div class="mini">
                      <div class="k">種類（倍率 / マイナス）</div>
                      <div class="row" id="typeRow"></div>
                      <div class="muted" style="margin-top:8px;">
                        例：普通70点 × ゴールド2.80 = 196点（＋連続ボーナス）
                      </div>
                    </div>
                  </div>

                  <div class="mini" style="margin-top:10px;">
                    <div class="k">時間</div>
                    <div>
                      まず<b>30秒</b>。30秒時点でスコアが <b id="unlockTxt">600</b> 点以上なら <b>60秒</b> まで延長。
                      <br>
                      延長できた場合、<b>45秒</b>から<b>鬼モード</b>（突入時に一瞬停止・天敵強化）。
                    </div>
                  </div>

                  <div class="muted" style="margin-top:10px;font-size:11px;">
                    ※開始ボタンは常に画面内に残るので、スマホでもスクロール不要です。
                  </div>
                </div>
                <div class="panel-foot">
                  <button id="startBtn" class="btn" type="button">スタート</button>
                  <button id="closeBtn" class="btn ghost" type="button">閉じる</button>
                </div>
              </div>
            </div>

            <!-- Result Overlay -->
            <div id="resultOverlay" class="overlay" role="dialog" aria-modal="true" aria-label="結果">
              <div class="panel">
                <div class="panel-head">
                  <div class="h" id="resultTitle">結果</div>
                  <button id="resultCloseX" class="btn ghost" type="button" aria-label="閉じる">×</button>
                </div>
                <div class="panel-body" id="resultBody">
                  <div class="resultMain" id="resultMain"></div>
                  <div class="resultLines" id="resultLines"></div>

                  <!-- SP Surprise block (shown only if won) -->
                  <div id="spBlock" class="spBox" style="display:none;">
                    <div class="spImg"><img id="spImgEl" alt="SPカード" /></div>
                    <div class="spQ">図鑑にいれますか？</div>
                    <div class="spBtns">
                      <button id="spYesBtn" class="btn" type="button">はい</button>
                      <button id="spNoBtn" class="btn ghost" type="button">いいえ</button>
                    </div>
                  </div>
                </div>
                <div class="panel-foot">
                  <button id="againBtn" class="btn" type="button">もう一回</button>
                  <button id="resultCloseBtn" class="btn ghost" type="button">閉じる</button>
                </div>
              </div>
            </div>

          </div>

          <div class="footnote">
            タップで糸を落下 → 当てる → 巻き上げ。天敵に当たると奪われる。
          </div>
        </div>
      </section>
    </main>
  </div>

<script>
(() => {
  "use strict";

  /* =========================================================
     ✅ SPサプライズ（ルール非表示/ボタン無し）
       - -500～-2999 : 10%で SP-03
       - 1000～1999  : 10%で SP-04
       - 2000～2999  : 10%で SP-05
       - 3000以上    : 10%で SP-06
     ✅ 当たったら結果画面でカード画像表示 → 「図鑑にいれますか？」(はい/いいえ)
        - はい：図鑑(tf_v1_book)へ保存
        - いいえ：保存しない
        - どちらでも図鑑へ移動しない
     ✅ 糸の速度：少しだけ減速（落下/巻き上げ）
     ✅ ルール画面背景：海中っぽい模様
  ========================================================= */

  /* =========================
     0) Storage keys
  ========================= */
  const FISH_LS = {
    best: "takoyakiFishing_best_points",
    last: "takoyakiFishing_last_points",
    playedAt: "takoyakiFishing_last_played",
    compat: "fish_v1_state",
    zukan: "tf_v1_book",
  };

  function readIntLS(key, def=0){
    const raw = localStorage.getItem(key);
    const n = Math.floor(Number(raw));
    return Number.isFinite(n) ? n : def;
  }
  function setText(id, v){
    const el = document.getElementById(id);
    if (el) el.textContent = String(v);
  }
  function formatLocal(dt){
    const y = dt.getFullYear();
    const m = String(dt.getMonth()+1).padStart(2,"0");
    const d = String(dt.getDate()).padStart(2,"0");
    const hh = String(dt.getHours()).padStart(2,"0");
    const mm = String(dt.getMinutes()).padStart(2,"0");
    return `${y}/${m}/${d} ${hh}:${mm}`;
  }

  function saveFishingRecord(score){
    score = Math.floor(Number(score) || 0);
    localStorage.setItem(FISH_LS.last, String(score));
    localStorage.setItem(FISH_LS.playedAt, new Date().toISOString());

    const best = readIntLS(FISH_LS.best, 0);
    const isNew = score > best;
    const newBest = isNew ? score : best;
    if (isNew) localStorage.setItem(FISH_LS.best, String(score));

    try{
      let st = {};
      try{ st = JSON.parse(localStorage.getItem(FISH_LS.compat) || "{}"); }catch(_){}
      st.best = Math.max(Math.floor(Number(st.best)||0), newBest);
      st.last = score;
      st.updatedAt = Date.now();
      localStorage.setItem(FISH_LS.compat, JSON.stringify(st));
    }catch(_){}

    return { best: newBest, isNew };
  }

  /* =========================
     1) SP Surprise (no rules / no game UI)
     - 抽選は「結果確定時」に行い、当たったら結果画面で保存確認
  ========================= */
  const CDN_BASE = "https://cdn.jsdelivr.net/gh/takoyaki-trc/takoyaki-gate@main/assets/takofish/";
  const V = "1";

  const SP_CFG = {
    chance: 0.10,
    // 図鑑側のIDに合わせる（必要ならここだけ変える）
    ids: {
      sp03: "sp_03",
      sp04: "sp_04",
      sp05: "sp_05",
      sp06: "sp_06",
    },
    // 結果画面に出すカード画像（必要ならURL差し替え）
    // ※ファイル名が違う場合：ここだけ修正
    img: {
      sp03: `${CDN_BASE}sp_03.png?v=${V}`,
      sp04: `${CDN_BASE}sp_04.png?v=${V}`,
      sp05: `${CDN_BASE}sp_05.png?v=${V}`,
      sp06: `${CDN_BASE}sp_06.png?v=${V}`,
    }
  };

  function getSPBucket(score){
    score = Math.floor(Number(score)||0);
    if (score <= -500 && score >= -2999) return "sp03";
    if (score >= 1000 && score <= 1999) return "sp04";
    if (score >= 2000 && score <= 2999) return "sp05";
    if (score >= 3000) return "sp06";
    return null;
  }

  function rollSP(score){
    const bucket = getSPBucket(score);
    if (!bucket) return null;
    if (Math.random() >= SP_CFG.chance) return null;
    return {
      bucket,
      id: SP_CFG.ids[bucket],
      img: SP_CFG.img[bucket] || "",
    };
  }

  function saveSPToZukan(sp){
    if (!sp || !sp.id) return false;
    const now = Date.now();
    try{
      let book = {};
      try{ book = JSON.parse(localStorage.getItem(FISH_LS.zukan) || "{}"); }catch(_){ book = {}; }
      if (!book || typeof book !== "object") book = {};
      if (!book.got || typeof book.got !== "object") book.got = {};
      if (!book.got[sp.id] || typeof book.got[sp.id] !== "object"){
        book.got[sp.id] = { count: 0 };
      }
      book.got[sp.id].count = Math.max(0, Math.floor(Number(book.got[sp.id].count)||0)) + 1;
      book.got[sp.id].lastAt = now;
      book.updatedAt = now;
      localStorage.setItem(FISH_LS.zukan, JSON.stringify(book));
      return true;
    }catch(_){
      return false;
    }
  }

  /* =========================
     2) Images (game assets)
  ========================= */
  const IMG_URLS = {
    pick:          `${CDN_BASE}pick.png?v=${V}`,
    sauce:         `${CDN_BASE}tako_sauce.png?v=${V}`,
    ika_tako:      `${CDN_BASE}tako_ika.png?v=${V}`,
    gold:          `${CDN_BASE}tako_gold.png?v=${V}`,
    rainbow:       `${CDN_BASE}tako_rainbow.png?v=${V}`,
    raw:           `${CDN_BASE}tako_raw.png?v=${V}`,
    tourist_left:  `${CDN_BASE}tourist_left.png?v=${V}`,
    tourist_right: `${CDN_BASE}tourist_right.png?v=${V}`,
    squid:         `${CDN_BASE}ika.png?v=${V}`,
  };

  function loadImage(src){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error(src));
      img.src = src;
    });
  }
  async function loadAllImages(){
    const keys = Object.keys(IMG_URLS);
    const images = {};
    const failed = [];
    for (const k of keys){
      try{ images[k] = await loadImage(IMG_URLS[k]); }
      catch(e){ failed.push({ key:k, url:String(e.message || e) }); }
    }
    return { images, failed };
  }

  /* =========================
     3) Game config
  ========================= */
  const CFG = {
    W: 360,
    H: 520,

    BASE_LIMIT: 30,
    EXT_LIMIT: 60,
    EXT_SCORE: 600,
    ONI_AT: 45,
    ONI_FREEZE_MS: 300,
    ONI_SPEED_MUL: 2.2,

    // ✅ 糸：少しだけ減速（前回より遅い）
    HOOK_DROP_BASE: 740,
    HOOK_REEL_BASE: 380,

    HOOK_HIT_R: 10,
    TOP_Y: 18,
    FLOOR_Y_RATIO: 0.86,
    PICK_DRAW: 24,

    ITEM_COUNT: 7,
    ITEM_BASE_SPEED: 45,
    ITEM_MAX_SPEED: 130,
    ITEM_ACCEL: 240,

    GIANT_DROP_CHANCE: 0.18,
    GIANT_DROP_START_Y_RATIO: 0.62,

    SIZE: {
      tiny:   { label: "極小",  draw: 24, base: 120 },
      normal: { label: "普通",  draw: 40, base: 70  },
      giant:  { label: "巨大",  draw: 56, base: 40  },
    },
    SIZE_WEIGHTS: [
      { key: "normal", w: 62 },
      { key: "tiny",   w: 28 },
      { key: "giant",  w: 10 },
    ],

    TYPE: {
      sauce:   { label: "ソース",     mult: 1.00, kind: "plus",  imgKey: "sauce" },
      ika:     { label: "いかさま",   mult: 1.40, kind: "plus",  imgKey: "ika_tako" },
      gold:    { label: "ゴールド",   mult: 2.80, kind: "plus",  imgKey: "gold" },
      rainbow: { label: "レインボー", mult: 5.50, kind: "plus",  imgKey: "rainbow" },
      raw:     { label: "生焼け",     mult: 0.00, kind: "minus", imgKey: "raw", penalty: -120 },
    },
    TYPE_WEIGHTS: [
      { key: "sauce",   w: 55 },
      { key: "ika",     w: 20 },
      { key: "gold",    w: 10 },
      { key: "rainbow", w:  5 },
      { key: "raw",     w: 10 },
    ],

    ENEMY_CENTER_Y_RATIO: 0.45,
    ENEMY_GAP: 170,

    TOURIST: { w: 34, h: 18, speed: 90 },
    SQUID: { w: 58, h: 58, speed: 18, ampX: 10, ampY: 16, freq: 0.55 },

    DASH: {
      yBias: -12,
      w: 54, h: 10,
      speed: 950,
      minS: 10, maxS: 15,
      oniMinS: 4, oniMaxS: 7,
      trail: 4,
    },

    MARGIN_X: 10,
  };

  /* =========================
     4) Ranks
  ========================= */
  const RANKS_MINUS = [
    { min: -1000, max: -1000, name: "〘未投入〙", line: "鉄板に、置かれていない。" },
    { min: -999,  max: -900,  name: "〘焼かれていない存在〙", line: "まだ、始まってすらいない。" },
    { min: -899,  max: -800,  name: "〘生焼け信者（末期）〙", line: "これは“通”の味。" },
    { min: -799,  max: -700,  name: "〘回収係に顔を覚えられた〙", line: "また来たんですね。" },
    { min: -699,  max: -600,  name: "〘ソース未装備〙", line: "武器を忘れてきた。" },
    { min: -599,  max: -500,  name: "〘焼き台に謝ってる人〙", line: "違う、そうじゃない。" },
    { min: -499,  max: -400,  name: "〘粉に戻った人〙", line: "最初からやり直せると思った？" },
    { min: -399,  max: -300,  name: "〘鉄板の外側〙", line: "そこ、焼けない。" },
    { min: -299,  max: -200,  name: "〘回収対象（仮）〙", line: "まだ返せると思っている。" },
    { min: -199,  max: -100,  name: "〘生焼け肯定派〙", line: "これはこれで、って言い始めた。" },
    { min: -99,   max: -1,    name: "〘ひっくり返し忘れ〙", line: "あっ、って言った。" },
  ];
  const RANKS_PLUS = [
    { min: 0,    max: 149,  name: "〘粉の妖精（未焼成）〙", line: "まだ丸くすらない。人生も。" },
    { min: 150,  max: 299,  name: "〘ソースの素振りマン〙", line: "かけてないのに、気持ちだけ濃い。" },
    { min: 300,  max: 449,  name: "〘青のり散らし職人（風）〙", line: "職人“風”って言った？言ったね？" },
    { min: 450,  max: 599,  name: "〘祭壇の前で深呼吸する人〙", line: "扉の前で呼吸するな。焼ける。" },
    { min: 600,  max: 699,  name: "〘延長の民（帰れない）〙", line: "帰ろうと思った瞬間、延長が始まる。" },
    { min: 700,  max: 799,  name: "〘潮目の読み間違い王〙", line: "読むな。感じろ。だいたい外れる。" },
    { min: 800,  max: 899,  name: "〘鬼モード予備軍（危険物）〙", line: "近づくな。熱さに慣れた目をしてる。" },
    { min: 900,  max: 999,  name: "〘回収されがちコレクター〙", line: "取ったと思ったら、取られてる。人生。" },
    { min: 1000, max: 1149, name: "〘焼き台の反復横跳び〙", line: "足が速いのに、目的が分からない。" },
    { min: 1150, max: 1299, name: "〘深海市場の常連（財布が不穏）〙", line: "買うな。回収される。なぜ来た。" },
    { min: 1300, max: 1449, name: "〘図鑑を開く手が震える人〙", line: "ページめくると、たこ焼き増えると思ってる？" },
    { min: 1450, max: 1599, name: "〘旅路の証っぽいもの保持者〙", line: "“っぽいもの”って言ったら全部軽くなる。" },
    { min: 1600, max: 1749, name: "〘流れと握手した人〙", line: "握手した手が、もう戻ってこない。" },
    { min: 1750, max: 1899, name: "〘観測者（現場猫）〙", line: "ヨシ！って言った瞬間、全部持ってかれた。" },
    { min: 1900, max: 1999, name: "〘黒潮と同棲中〙", line: "家賃？払ってるのはメンタル。" },
    { min: 2000, max: 2199, name: "〘仕様の外で生きてる人〙", line: "説明書が逃げた。戻ってこない。" },
    { min: 2200, max: 2399, name: "〘焼かれた伝説（胃もたれ付き）〙", line: "伝説は重い。胃も重い。" },
    { min: 2400, max: 2499, name: "〘禁断の回収免許皆伝〙", line: "免許？返納しろ。危ない。" },
    { min: 2500, max: 2699, name: "〘観測不能（本人も不明）〙", line: "あなた誰？こっちが聞きたい。" },
    { min: 2700, max: 2899, name: "〘祭壇が先にお辞儀した人〙", line: "偉いのはあなたじゃない。祭壇だ。" },
    { min: 2900, max: 2999, name: "〘世界の外側でたこ焼き数えてる人〙", line: "数えるな。戻れなくなる。" },
    { min: 3001, max: 3299, name: "〘上限突破：序章〙", line: "ここから先は、説明書が燃える。" },
    { min: 3300, max: 3599, name: "〘回収無効化〙", line: "奪われない。奪わせない。" },
    { min: 3600, max: 3999, name: "〘鬼の手元〙", line: "指先が熱を覚えている。" },
    { min: 4000, max: 4499, name: "〘鉄板と同調〙", line: "揺れが読める。世界が遅い。" },
    { min: 4500, max: 4999, name: "〘潮目支配〙", line: "流れを避けるんじゃない。使う。" },
    { min: 5000, max: 5499, name: "〘焼成管理者〙", line: "火加減ではなく、運命を回している。" },
    { min: 5500, max: 5999, name: "〘神速の返し〙", line: "拾う前に、もう次を取っている。" },
    { min: 6000, max: 6499, name: "〘回収の外側〙", line: "観光客が止まって見える。" },
    { min: 6500, max: 6999, name: "〘深海の釣神〙", line: "海が静かに道を空ける。" },
    { min: 7000, max: 7499, name: "〘レインボー統制〙", line: "色が来るタイミングが分かる。" },
    { min: 7500, max: 7999, name: "〘鬼モード常駐〙", line: "もう戻れない。戻る必要もない。" },
    { min: 8000, max: 8499, name: "〘焼かれた伝説：真〙", line: "伝説は“結果”ではなく“操作”だった。" },
    { min: 8500, max: 8999, name: "〘鉄板の王〙", line: "火傷しない。火傷が逃げる。" },
    { min: 9000, max: 9499, name: "〘世界線固定〙", line: "揺れが消える。残るのは精度。" },
    { min: 9500, max: 9999, name: "〘釣り台の神〙", line: "あなたが動く前に、たこ焼きが寄る。" },
    { min: 10000, max: 999999, name: "〘運営側〙", line: "……テストプレイ、ありがとうございます。" },
  ];

  const SCORE_3000_LINE = "それでも、たこ焼きは残らなかった。";

  function getRank(score){
    if (score === 3000) return null;
    const list = (score < 0) ? RANKS_MINUS : RANKS_PLUS;
    if (score < list[0].min) return list[0];
    if (score > list[list.length - 1].max) return list[list.length - 1];
    for (const r of list){
      if (score >= r.min && score <= r.max) return r;
    }
    return list[list.length - 1];
  }

  /* =========================
     5) Helpers / Physics
  ========================= */
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function pickByWeight(list){
    let sum = 0;
    for (const it of list) sum += it.w;
    let r = Math.random() * sum;
    for (const it of list){
      r -= it.w;
      if (r <= 0) return it.key;
    }
    return list[list.length-1].key;
  }
  function circleHit(ax,ay,ar,bx,by,br){
    const dx=ax-bx, dy=ay-by;
    return (dx*dx+dy*dy) <= (ar+br)*(ar+br);
  }
  function circleRectHit(cx, cy, cr, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx + rw);
    const ny = clamp(cy, ry, ry + rh);
    const dx = cx - nx;
    const dy = cy - ny;
    return (dx*dx + dy*dy) <= cr*cr;
  }
  function nowMs(){ return performance.now(); }

  function buildTakoyakiSpec(){
    const sizeKey = pickByWeight(CFG.SIZE_WEIGHTS);
    const typeKey = pickByWeight(CFG.TYPE_WEIGHTS);
    const size = CFG.SIZE[sizeKey];
    const type = CFG.TYPE[typeKey];

    let points = 0;
    if (type.kind === "minus") points = type.penalty;
    else points = Math.round(size.base * type.mult);

    return { sizeKey, size, type, points };
  }

  function pointerToCanvasX(e, cvs){
    const rect = cvs.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (CFG.W / rect.width);
    return clamp(x, CFG.MARGIN_X, CFG.W - CFG.MARGIN_X);
  }

  // 体感改善（変化付き） ※速度は減らしつつ、カーブは維持
  function hookDropSpeed(hy, floorY){
    const t = clamp((hy - CFG.TOP_Y) / Math.max(1, (floorY - CFG.TOP_Y)), 0, 1);
    const mul = 1.04 + 0.68 * t; // 1.04 → 1.72
    return CFG.HOOK_DROP_BASE * mul;
  }
  function hookReelSpeed(hy, floorY, hasCatch){
    const t = clamp((hy - CFG.TOP_Y) / Math.max(1, (floorY - CFG.TOP_Y)), 0, 1);
    const mul = (1.30 + 0.80 * (1 - t)); // 2.10 → 1.30
    const catchMul = hasCatch ? 1.18 : 1.04;
    return CFG.HOOK_REEL_BASE * mul * catchMul;
  }

  /* =========================
     6) UI Wiring
  ========================= */
  const els = {
    backBtn: document.getElementById("backBtn"),
    retryBtn: document.getElementById("retryBtn"),
    rulesBtn: document.getElementById("rulesBtn"),
    rulesOverlay: document.getElementById("rulesOverlay"),
    rulesCloseX: document.getElementById("rulesCloseX"),
    startBtn: document.getElementById("startBtn"),
    closeBtn: document.getElementById("closeBtn"),

    resultOverlay: document.getElementById("resultOverlay"),
    resultTitle: document.getElementById("resultTitle"),
    resultMain: document.getElementById("resultMain"),
    resultLines: document.getElementById("resultLines"),
    resultCloseX: document.getElementById("resultCloseX"),
    resultCloseBtn: document.getElementById("resultCloseBtn"),
    againBtn: document.getElementById("againBtn"),

    spBlock: document.getElementById("spBlock"),
    spImgEl: document.getElementById("spImgEl"),
    spYesBtn: document.getElementById("spYesBtn"),
    spNoBtn: document.getElementById("spNoBtn"),

    canvas: document.getElementById("tfCanvas"),
    sizeRow: document.getElementById("sizeRow"),
    typeRow: document.getElementById("typeRow"),
    unlockTxt: document.getElementById("unlockTxt"),
  };

  function refreshBestUI(){
    setText("tfBest", readIntLS(FISH_LS.best, 0));
  }
  refreshBestUI();

  els.backBtn.addEventListener("click", () => {
    try{
      if (history.length > 1) history.back();
      else location.href = "../town/";
    }catch(_){
      location.href = "../town/";
    }
  });

  function showRules(){ els.rulesOverlay.classList.add("show"); }
  function hideRules(){ els.rulesOverlay.classList.remove("show"); }
  function showResult(){ els.resultOverlay.classList.add("show"); }
  function hideResult(){ els.resultOverlay.classList.remove("show"); }

  els.rulesBtn.addEventListener("click", showRules);
  els.rulesCloseX.addEventListener("click", hideRules);
  els.closeBtn.addEventListener("click", hideRules);

  els.resultCloseX.addEventListener("click", () => { hideResult(); showRules(); });
  els.resultCloseBtn.addEventListener("click", () => { hideResult(); showRules(); });

  /* =========================
     7) Build rule visuals using SAME game images
  ========================= */
  let IMGS = null;
  function buildRuleVisuals(){
    els.unlockTxt.textContent = String(CFG.EXT_SCORE);
    els.sizeRow.innerHTML = `
      <span class="chip">極小：<b>${CFG.SIZE.tiny.base}</b></span>
      <span class="chip">普通：<b>${CFG.SIZE.normal.base}</b></span>
      <span class="chip">巨大：<b>${CFG.SIZE.giant.base}</b></span>
    `;

    const makeType = (key, txt) => {
      const imgKey = CFG.TYPE[key].imgKey;
      const src = IMG_URLS[imgKey];
      return `
        <span class="chip">
          <img class="iconimg" src="${src}" alt="${CFG.TYPE[key].label}">
          ${txt}
        </span>
      `;
    };

    els.typeRow.innerHTML = [
      makeType("sauce", `ソース ×<b>${CFG.TYPE.sauce.mult.toFixed(2)}</b>`),
      makeType("ika", `いかさま ×<b>${CFG.TYPE.ika.mult.toFixed(2)}</b>`),
      makeType("gold", `ゴールド ×<b>${CFG.TYPE.gold.mult.toFixed(2)}</b>`),
      makeType("rainbow", `レインボー ×<b>${CFG.TYPE.rainbow.mult.toFixed(2)}</b>`),
      makeType("raw", `生焼け <b>${CFG.TYPE.raw.penalty}</b>`),
    ].join("");
  }

  /* =========================
     8) Game runtime state
  ========================= */
  let rafId = null;
  let timerId = null;
  let onPointer = null;
  let STATE = null;

  // ✅ SP保留（結果画面で「はい/いいえ」）
  let SP_PENDING = null;
  let SP_DECIDED = false;

  function stopGame(){
    if (timerId) clearInterval(timerId);
    timerId = null;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;

    const cvs = els.canvas;
    if (cvs && onPointer) cvs.removeEventListener("pointerdown", onPointer);
    onPointer = null;

    STATE = null;
  }

  function flashText(msg, ms){
    if (!STATE) return;
    STATE.flashMsg = msg;
    STATE.flashUntil = nowMs() + ms;
  }

  function drawImageCentered(ctx, img, x, y, size){
    ctx.drawImage(img, Math.round(x - size/2), Math.round(y - size/2), size, size);
  }

  /* =========================
     9) Result render (includes datetime + best)
     ✅ SP当選時：画像 + 図鑑保存確認
  ========================= */
  function resetSPUI(){
    SP_PENDING = null;
    SP_DECIDED = false;
    els.spBlock.style.display = "none";
    els.spImgEl.removeAttribute("src");
  }

  function showSPPrompt(sp){
    if (!sp || !sp.img) return;
    els.spImgEl.src = sp.img;
    els.spBlock.style.display = "block";
  }

  els.spYesBtn.addEventListener("click", () => {
    if (SP_DECIDED) return;
    SP_DECIDED = true;
    if (SP_PENDING) saveSPToZukan(SP_PENDING);
    // ボタンは消す（結果画面はそのまま）
    els.spBlock.style.display = "none";
  });

  els.spNoBtn.addEventListener("click", () => {
    if (SP_DECIDED) return;
    SP_DECIDED = true;
    // 保存しない
    els.spBlock.style.display = "none";
  });

  function showResultScreen(score, extended, oniReached){
    const rec = saveFishingRecord(score);
    refreshBestUI();

    // SP抽選（結果確定時）
    resetSPUI();
    SP_PENDING = rollSP(score);

    const dt = new Date();
    const played = formatLocal(dt);
    const best = rec.best;
    const isNew = rec.isNew;

    els.resultTitle.innerHTML = isNew ? `結果<span class="tagNew">NEW RECORD</span>` : "結果";

    if (score === 3000){
      els.resultMain.textContent = SCORE_3000_LINE;
      const lines = [];
      lines.push(`日時：<b>${played}</b>`);
      lines.push(`Score：<b>${score}</b>`);
      lines.push(`Best：<b>${best}</b>${isNew ? "（更新）" : ""}`);
      els.resultLines.innerHTML = lines.map(s => `<div>${s}</div>`).join("");

      if (SP_PENDING) showSPPrompt(SP_PENDING);
      showResult();
      return;
    }

    const r = getRank(score);
    els.resultMain.textContent = `［ ${r.name} ］`;

    const lines = [];
    lines.push(r.line);
    lines.push(`日時：<b>${played}</b>`);
    lines.push(`Score：<b>${score}</b>`);
    lines.push(`Best：<b>${best}</b>${isNew ? "（更新）" : ""}`);
    lines.push(extended ? "延長：あり（60秒）" : "延長：なし（30秒）");
    if (extended) lines.push(oniReached ? "鬼モード：到達" : "鬼モード：未到達");

    els.resultLines.innerHTML = lines.map(s => `<div>${s}</div>`).join("");

    if (SP_PENDING) showSPPrompt(SP_PENDING);
    showResult();
  }

  /* =========================
     10) Game start
  ========================= */
  function startGame(){
    stopGame();
    hideResult();
    hideRules();
    resetSPUI();

    const cvs = els.canvas;
    const ctx = cvs.getContext("2d");
    ctx.imageSmoothingEnabled = false;

    const scoreEl = document.getElementById("tfScore");
    const timeEl  = document.getElementById("tfTime");
    const comboEl = document.getElementById("tfCombo");
    const missEl  = document.getElementById("tfMiss");

    const W = CFG.W, H = CFG.H;
    const FLOOR_Y = Math.floor(H * CFG.FLOOR_Y_RATIO);
    const GIANT_DROP_START_Y = Math.floor(H * CFG.GIANT_DROP_START_Y_RATIO);

    const ENEMY_CENTER_Y = Math.floor(H * CFG.ENEMY_CENTER_Y_RATIO);
    const TOURIST_Y = ENEMY_CENTER_Y - Math.floor(CFG.ENEMY_GAP * 0.55);
    const SQUID_Y   = ENEMY_CENTER_Y + Math.floor(CFG.ENEMY_GAP * 0.55);

    STATE = {
      elapsed: 0,
      limit: CFG.BASE_LIMIT,
      extended: false,
      oni: false,
      oniReached: false,
      freezeUntil: 0,

      score: 0,
      combo: 0,
      miss: 0,

      flashMsg: "",
      flashUntil: 0,

      items: [],
      hook: null,
      tourist: null,
      squid: null,
      dash: null,
      dashTrail: [],

      ended: false,
    };

    function remaining(){ return Math.max(0, STATE.limit - STATE.elapsed); }

    for (let i=0; i<CFG.ITEM_COUNT; i++){
      const spec = buildTakoyakiSpec();
      const baseY = (FLOOR_Y - 14) + rand(-2, 2);
      STATE.items.push({
        x: rand(W*0.15, W*0.85),
        baseY,
        y: baseY,
        alive: true,
        spec,
        vx: (Math.random()<0.5?-1:1) * (CFG.ITEM_BASE_SPEED + rand(0,22)),
        vxTarget: (Math.random()<0.5?-1:1) * (CFG.ITEM_BASE_SPEED + rand(0,50)),
        bobAmp: rand(0.6,2.4),
        bobSpd: rand(3.0,7.8),
        bobPhase: rand(0, Math.PI*2),
        nextMind: nowMs() + rand(450,1100),
        pauseUntil: 0,
      });
    }

    function resetItem(it){
      it.spec = buildTakoyakiSpec();
      const baseY = (FLOOR_Y - 14) + rand(-2,2);
      it.x = rand(W*0.15, W*0.85);
      it.baseY = baseY;
      it.y = baseY;
      it.alive = true;
      it.vx = (Math.random()<0.5?-1:1) * (CFG.ITEM_BASE_SPEED + rand(0,22));
      it.vxTarget = (Math.random()<0.5?-1:1) * (CFG.ITEM_BASE_SPEED + rand(0,50));
      it.bobAmp = rand(0.6,2.4);
      it.bobSpd = rand(3.0,7.8);
      it.bobPhase = rand(0,Math.PI*2);
      it.nextMind = nowMs() + rand(450,1100);
      it.pauseUntil = 0;
    }

    STATE.hook = {
      x: W*0.5,
      y: CFG.TOP_Y,
      phase: "idle",
      hitR: CFG.HOOK_HIT_R,
      hasCatch: false,
      caught: null,
      giantDropArmed: false,
      giantDropRolled: false,
      giantWillDrop: false,
    };

    function setHookIdle(){
      const h = STATE.hook;
      h.phase = "idle";
      h.y = CFG.TOP_Y;
      h.hasCatch = false;
      h.caught = null;
      h.giantDropArmed = false;
      h.giantDropRolled = false;
      h.giantWillDrop = false;
    }

    STATE.tourist = { x: 0, y: TOURIST_Y, w: CFG.TOURIST.w, h: CFG.TOURIST.h, dir: 1, speed: CFG.TOURIST.speed };
    STATE.squid = {
      baseX: W - CFG.SQUID.w, baseY: SQUID_Y, x: W - CFG.SQUID.w, y: SQUID_Y,
      w: CFG.SQUID.w, h: CFG.SQUID.h, dir: -1,
      speed: CFG.SQUID.speed, ampX: CFG.SQUID.ampX, ampY: CFG.SQUID.ampY, freq: CFG.SQUID.freq,
      phase: Math.random()*Math.PI*2,
    };

    const dashY = Math.floor((TOURIST_Y + SQUID_Y) * 0.5) + CFG.DASH.yBias;
    STATE.dash = { active:false, x: W + 60, y: dashY, w: CFG.DASH.w, h: CFG.DASH.h, vx: -CFG.DASH.speed, nextAt: nowMs() + (CFG.DASH.minS*1000 + Math.random()*(CFG.DASH.maxS-CFG.DASH.minS)*1000) };

    function spawnDash(now){
      const d = STATE.dash;
      d.active = true;
      d.x = W + d.w + 10;
      d.vx = -CFG.DASH.speed * (STATE.oni ? 1.15 : 1.0);

      const minS = STATE.oni ? CFG.DASH.oniMinS : CFG.DASH.minS;
      const maxS = STATE.oni ? CFG.DASH.oniMaxS : CFG.DASH.maxS;
      d.nextAt = now + (minS*1000 + Math.random()*(maxS-minS)*1000);

      STATE.dashTrail.length = 0;
      flashText("⚠ 流れが来た", 520);
    }
    function despawnDash(){
      const d = STATE.dash;
      d.active = false;
      d.x = W + d.w + 10;
    }

    function applyCatchScore(spec){
      if (spec.type.kind === "minus"){
        STATE.score += spec.points;
        STATE.combo = 0;
        STATE.miss++;
        flashText(`ハズレ！${spec.type.label} ${spec.points}`, 900);
        return;
      }
      STATE.combo++;
      const comboBonus = Math.min(120, STATE.combo * 6);
      STATE.score += spec.points + comboBonus;
      flashText(`GET! +${spec.points}（${spec.size.label}/${spec.type.label}）`, 850);
    }

    function onStolen(who){
      STATE.combo = 0;
      STATE.miss++;
      if (who === "squid"){
        STATE.score -= 40;
        flashText("イカに奪われた… -40", 950);
      } else {
        flashText("観光客に横取りされた！", 850);
      }
      setHookIdle();
    }

    function onDropGiant(){
      STATE.combo = 0;
      STATE.miss++;
      flashText("巨大たこ焼き、落ちた！！", 950);
      setHookIdle();
    }

    function startDropAt(x){
      if (remaining() <= 0) return;
      const h = STATE.hook;
      if (h.phase !== "idle") return;
      h.x = clamp(x, CFG.MARGIN_X, W - CFG.MARGIN_X);
      h.phase = "drop";
      h.hasCatch = false;
      h.caught = null;
      h.giantDropArmed = false;
      h.giantDropRolled = false;
      h.giantWillDrop = false;
    }

    onPointer = (e) => { e.preventDefault(); startDropAt(pointerToCanvasX(e, cvs)); };
    cvs.addEventListener("pointerdown", onPointer, { passive:false });

    function drawBackground(now){
      const isOni = STATE.oni;
      ctx.fillStyle = isOni ? "#060819" : "#081425";
      ctx.fillRect(0, 0, W, H);

      const t = now / 1000;
      const band1 = Math.floor(40 + 12 * Math.sin(t * 0.6));
      const band2 = Math.floor(70 + 18 * Math.cos(t * 0.42));
      ctx.fillStyle = isOni ? "rgba(120,70,170,0.07)" : "rgba(60,130,220,0.07)";
      ctx.fillRect(0, 0, W, band1);
      ctx.fillRect(0, band1 + 50, W, band2);

      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(0, FLOOR_Y, W, H - FLOOR_Y);
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      ctx.fillRect(0, FLOOR_Y - 6, W, 6);

      if (isOni){
        ctx.fillStyle = "rgba(0,255,255,0.04)";
        ctx.fillRect(0,0,W,H);
      }
    }

    function drawItems(){
      for (const it of STATE.items){
        if (!it.alive) continue;
        const img = IMGS[it.spec.type.imgKey];
        drawImageCentered(ctx, img, it.x, it.y, it.spec.size.draw);
      }
    }

    function drawTourist(){
      const t = STATE.tourist;
      const img = (t.dir > 0) ? IMGS.tourist_right : IMGS.tourist_left;
      drawImageCentered(ctx, img, t.x + t.w/2, t.y, 44);
    }

    function drawSquid(){
      const s = STATE.squid;
      const img = IMGS.squid;
      const cx = s.x + s.w/2;
      const cy = s.y;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(s.dir, 1);
      ctx.drawImage(img, Math.round(-s.w/2), Math.round(-s.h/2), s.w, s.h);
      ctx.restore();
    }

    function drawDash(now){
      const d = STATE.dash;
      if (!d.active) return;

      const trail = STATE.dashTrail;
      trail.unshift({ x: d.x, t: now });
      if (trail.length > CFG.DASH.trail) trail.pop();

      for (let i=trail.length-1; i>=0; i--){
        const a = (i+1) / (trail.length+1);
        const alpha = 0.12 + 0.22 * (1 - a);
        const wid = d.w + i * 14;
        const hi  = d.h + i * 2;

        const x = trail[i].x - i * 10;
        const y = d.y;

        ctx.fillStyle = `rgba(0, 220, 255, ${alpha})`;
        ctx.fillRect(Math.round(x), Math.round(y - hi/2), wid, hi);
      }

      ctx.fillStyle = "rgba(210, 255, 255, 0.35)";
      ctx.fillRect(Math.round(d.x), Math.round(d.y - d.h/2), d.w, d.h);

      ctx.fillStyle = "rgba(0, 255, 255, 0.35)";
      ctx.fillRect(Math.round(d.x + d.w - 6), Math.round(d.y - d.h/2), 6, d.h);
    }

    function drawHook(){
      const h = STATE.hook;
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.beginPath();
      ctx.moveTo(h.x, CFG.TOP_Y);
      ctx.lineTo(h.x, h.y);
      ctx.stroke();

      drawImageCentered(ctx, IMGS.pick, h.x, h.y, CFG.PICK_DRAW);

      if (h.hasCatch && h.caught){
        const s = h.caught.size.draw;
        const ty = h.y + (CFG.PICK_DRAW/2) + (s/2) - 2;
        const img = IMGS[h.caught.type.imgKey];
        drawImageCentered(ctx, img, h.x, ty, s);
      }
    }

    function drawHUD(now){
      ctx.fillStyle = "#fff";
      ctx.font = "13px system-ui";

      const h = STATE.hook;
      if (h.phase === "idle") ctx.fillText("タップ：好きな位置に糸を垂らす", 10, 18);
      else if (h.phase === "drop") ctx.fillText("落下中…当てろ！", 10, 18);
      else ctx.fillText("巻き上げ中！天敵に注意！", 10, 18);

      if (STATE.extended){
        ctx.fillStyle = "rgba(255,255,255,.75)";
        ctx.font = "12px system-ui";
        ctx.fillText("延長中", 10, 36);
      }
      if (STATE.oni){
        ctx.fillStyle = "rgba(0,255,255,.85)";
        ctx.font = "12px system-ui";
        ctx.fillText("鬼モード", 60, 36);
      }

      if (now < STATE.flashUntil && STATE.flashMsg){
        ctx.fillStyle = "rgba(0,0,0,.55)";
        ctx.fillRect(0, 44, W, 26);
        ctx.fillStyle = "#fff";
        ctx.font = "13px system-ui";
        ctx.fillText(STATE.flashMsg, 12, 62);
      }

      if (STATE.freezeUntil && now < STATE.freezeUntil){
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = "rgba(0,255,255,.9)";
        ctx.font = "18px system-ui";
        ctx.fillText("鬼モード突入", 110, 230);
      }

      if (remaining() <= 0){
        ctx.fillStyle = "rgba(0,0,0,.65)";
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = "#fff";
        ctx.font = "22px system-ui";
        ctx.fillText("TIME UP!", 120, 230);
      }
    }

    function render(now){
      drawBackground(now);
      drawTourist();
      drawSquid();
      drawDash(now);
      if (!STATE.hook.hasCatch) drawItems();
      drawHook();
      drawHUD(now);
    }

    timerId = setInterval(() => {
      if (remaining() <= 0) return;
      STATE.elapsed++;

      if (STATE.elapsed === CFG.BASE_LIMIT){
        if (STATE.score >= CFG.EXT_SCORE){
          STATE.extended = true;
          STATE.limit = CFG.EXT_LIMIT;
          flashText(`延長解放！60秒へ（30秒時点 ${STATE.score}点）`, 1200);
        } else {
          STATE.limit = CFG.BASE_LIMIT;
          flashText(`終了！延長条件：${CFG.EXT_SCORE}点（いま ${STATE.score}点）`, 1400);
        }
      }

      if (STATE.extended && STATE.elapsed === CFG.ONI_AT){
        STATE.oni = true;
        STATE.oniReached = true;
        STATE.freezeUntil = nowMs() + CFG.ONI_FREEZE_MS;
        flashText("鬼モード突入！！", 1000);
      }

      setText("tfTime", Math.max(0, STATE.limit - STATE.elapsed));
      setText("tfScore", STATE.score);
      setText("tfCombo", STATE.combo);
      setText("tfMiss", STATE.miss);

      if (remaining() <= 0 && !STATE.ended){
        STATE.ended = true;
        setTimeout(() => showResultScreen(STATE.score, STATE.extended, STATE.oniReached), 120);
      }
    }, 1000);

    let last = nowMs();

    function step(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      if (remaining() > 0){
        if (STATE.freezeUntil && now < STATE.freezeUntil){
          render(now);
          rafId = requestAnimationFrame(step);
          return;
        }

        const mul = STATE.oni ? CFG.ONI_SPEED_MUL : 1.0;

        for (const it of STATE.items){
          if (!it.alive) continue;

          if (now < it.pauseUntil){
            it.vx *= 0.90;
          } else {
            if (now >= it.nextMind){
              if (Math.random() < 0.10) it.pauseUntil = now + rand(260, 620);
              const flip = (Math.random() < 0.18) ? -1 : 1;
              const spd = CFG.ITEM_BASE_SPEED + rand(-18, 60);
              it.vxTarget = clamp(flip * (Math.random()<0.5?-1:1) * spd, -CFG.ITEM_MAX_SPEED, CFG.ITEM_MAX_SPEED);

              it.bobAmp = clamp(it.bobAmp + rand(-0.6, 0.9), 0.5, 3.4);
              it.bobSpd = clamp(it.bobSpd + rand(-1.2, 1.4), 2.0, 9.0);
              it.nextMind = now + rand(350, 1300);
            }

            const dv = it.vxTarget - it.vx;
            const stepV = clamp(dv, -CFG.ITEM_ACCEL*dt, CFG.ITEM_ACCEL*dt);
            it.vx += stepV;
            it.vx += rand(-6, 6) * dt;
            it.vx = clamp(it.vx, -CFG.ITEM_MAX_SPEED, CFG.ITEM_MAX_SPEED);
          }

          it.x += it.vx * dt;

          const half = it.spec.size.draw / 2;
          if (it.x - half < CFG.MARGIN_X){
            it.x = CFG.MARGIN_X + half;
            it.vx = Math.abs(it.vx) * (0.85 + Math.random()*0.25);
            it.vxTarget = Math.abs(it.vxTarget) * (0.8 + Math.random()*0.4);
            it.nextMind = Math.min(it.nextMind, now + rand(120, 420));
          }
          if (it.x + half > W - CFG.MARGIN_X){
            it.x = (W - CFG.MARGIN_X) - half;
            it.vx = -Math.abs(it.vx) * (0.85 + Math.random()*0.25);
            it.vxTarget = -Math.abs(it.vxTarget) * (0.8 + Math.random()*0.4);
            it.nextMind = Math.min(it.nextMind, now + rand(120, 420));
          }

          it.y = it.baseY + Math.sin((now/1000) * it.bobSpd + it.bobPhase) * it.bobAmp;
        }

        const t = STATE.tourist;
        t.x += t.dir * t.speed * mul * dt;
        if (t.x < 0){ t.x = 0; t.dir *= -1; }
        if (t.x + t.w > W){ t.x = W - t.w; t.dir *= -1; }

        const s = STATE.squid;
        s.baseX += s.dir * s.speed * mul * dt;
        if (s.baseX < 0){ s.baseX = 0; s.dir *= -1; }
        if (s.baseX + s.w > W){ s.baseX = W - s.w; s.dir *= -1; }

        const sec = (now/1000) * (Math.PI*2) * s.freq + s.phase;
        s.x = s.baseX + Math.sin(sec) * s.ampX;
        s.y = s.baseY + Math.cos(sec * 0.85) * s.ampY;

        const d = STATE.dash;
        if (!d.active && now >= d.nextAt) spawnDash(now);
        if (d.active){
          d.x += d.vx * dt;
          if (d.x + d.w < -40) despawnDash();
        }

        const h = STATE.hook;

        if (h.phase === "drop"){
          const spd = hookDropSpeed(h.y, FLOOR_Y);
          h.y += spd * dt;

          if (!h.hasCatch){
            for (const it of STATE.items){
              if (!it.alive) continue;
              const rr = it.spec.size.draw * 0.38;
              if (circleHit(h.x, h.y, h.hitR, it.x, it.y, rr)){
                h.hasCatch = true;
                h.phase = "reel";
                h.caught = it.spec;

                h.giantDropArmed = (it.spec.sizeKey === "giant");
                h.giantDropRolled = false;
                h.giantWillDrop = false;

                it.alive = false;
                flashText(`HIT!（${it.spec.size.label}/${it.spec.type.label}）`, 750);
                break;
              }
            }
          }

          if (h.y >= FLOOR_Y - 10){
            h.y = FLOOR_Y - 10;
            h.phase = "reel";
            if (!h.hasCatch){
              STATE.combo = 0;
              flashText("空振り…！", 600);
            }
          }
        }

        if (h.phase === "reel"){
          const spd = hookReelSpeed(h.y, FLOOR_Y, h.hasCatch);
          h.y -= spd * dt;

          if (h.hasCatch && h.caught && h.giantDropArmed){
            if (!h.giantDropRolled && h.y < GIANT_DROP_START_Y){
              h.giantDropRolled = true;
              h.giantWillDrop = (Math.random() < CFG.GIANT_DROP_CHANCE);
            }
            if (h.giantWillDrop && h.y < (GIANT_DROP_START_Y - 40)){
              const dead = STATE.items.find(v => !v.alive);
              if (dead) resetItem(dead);

              h.hasCatch = false;
              h.caught = null;

              STATE.combo = 0;
              STATE.miss++;
              flashText("巨大たこ焼き、落ちた！！", 950);
              setHookIdle();
            }
          }

          if (h.hasCatch && h.caught){
            const fishSize = h.caught.size.draw;
            const fishR = fishSize * 0.38;
            const fishX = h.x;
            const fishY = h.y + (CFG.PICK_DRAW/2) + (fishSize/2) - 2;

            if (circleRectHit(fishX, fishY, fishR, t.x, t.y - t.h/2, t.w, t.h)){
              const dead = STATE.items.find(v => !v.alive);
              if (dead) resetItem(dead);
              h.hasCatch = false; h.caught = null;
              STATE.combo = 0; STATE.miss++; flashText("観光客に横取りされた！", 850);
              setHookIdle();
            }

            if (h.hasCatch && circleRectHit(fishX, fishY, fishR, s.x, s.y - s.h/2, s.w, s.h)){
              const dead = STATE.items.find(v => !v.alive);
              if (dead) resetItem(dead);
              h.hasCatch = false; h.caught = null;
              STATE.combo = 0; STATE.miss++; STATE.score -= 40; flashText("イカに奪われた… -40", 950);
              setHookIdle();
            }

            if (h.hasCatch && d.active){
              if (circleRectHit(fishX, fishY, fishR, d.x, d.y - d.h/2, d.w, d.h)){
                const dead = STATE.items.find(v => !v.alive);
                if (dead) resetItem(dead);
                h.hasCatch = false; h.caught = null;
                STATE.combo = 0; STATE.miss++; flashText("観光客に横取りされた！", 850);
                setHookIdle();
                despawnDash();
              }
            }
          }

          if (h.y <= CFG.TOP_Y){
            h.y = CFG.TOP_Y;
            if (h.hasCatch && h.caught){
              const dead = STATE.items.find(v => !v.alive);
              if (dead) resetItem(dead);

              // score apply
              if (h.caught.type.kind === "minus"){
                STATE.score += h.caught.points;
                STATE.combo = 0;
                STATE.miss++;
                flashText(`ハズレ！${h.caught.type.label} ${h.caught.points}`, 900);
              } else {
                STATE.combo++;
                const comboBonus = Math.min(120, STATE.combo * 6);
                STATE.score += h.caught.points + comboBonus;
                flashText(`GET! +${h.caught.points}（${h.caught.size.label}/${h.caught.type.label}）`, 850);
              }

              h.hasCatch = false;
              h.caught = null;
              setHookIdle();
            } else {
              setHookIdle();
            }
          }
        }
      }

      setText("tfScore", STATE.score);
      setText("tfCombo", STATE.combo);
      setText("tfMiss", STATE.miss);
      setText("tfTime", Math.max(0, STATE.limit - STATE.elapsed));

      render(now);
      rafId = requestAnimationFrame(step);
    }

    setHookIdle();
    flashText("", 0);

    setText("tfScore", 0);
    setText("tfCombo", 0);
    setText("tfMiss", 0);
    setText("tfTime", CFG.BASE_LIMIT);

    rafId = requestAnimationFrame(step);
  }

  /* =========================
     11) Init: load images, build rule UI
  ========================= */
  async function init(){
    const ctx = els.canvas.getContext("2d");
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = "#081425";
    ctx.fillRect(0,0,CFG.W,CFG.H);
    ctx.fillStyle = "#fff";
    ctx.font = "16px system-ui";
    ctx.fillText("画像を読み込み中…", 100, 260);

    const { images, failed } = await loadAllImages();
    if (failed.length){
      ctx.fillStyle = "#081425";
      ctx.fillRect(0,0,CFG.W,CFG.H);
      ctx.fillStyle = "#fff";
      ctx.font = "14px system-ui";
      ctx.fillText("画像が読み込めないものがあります：", 20, 40);
      ctx.font = "11px system-ui";
      let y=70;
      for (const f of failed){
        ctx.fillText(`- ${f.key}: ${f.url}`, 20, y);
        y += 16;
        if (y > CFG.H - 30) break;
      }
      ctx.fillText("CDN_BASE / ファイル名を確認してください。", 20, CFG.H-16);
      return;
    }

    IMGS = images;
    buildRuleVisuals();
    showRules();
  }

  /* =========================
     12) Buttons
  ========================= */
  els.startBtn.addEventListener("click", startGame);

  els.retryBtn.addEventListener("click", () => {
    hideResult();
    showRules();
    stopGame();
    resetSPUI();
  });

  els.againBtn.addEventListener("click", () => {
    hideResult();
    showRules();
    stopGame();
    resetSPUI();
  });

  els.rulesOverlay.addEventListener("click", (e) => {
    if (e.target === els.rulesOverlay) hideRules();
  });
  els.resultOverlay.addEventListener("click", (e) => {
    if (e.target === els.resultOverlay){
      hideResult();
      showRules();
      resetSPUI();
    }
  });

  setText("tfBest", readIntLS(FISH_LS.best, 0));
  init();

})();
</script>
</body>
</html>
