
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
<title>ãŸã“ç„¼ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼</title>
<style>
  :root{
    --w: 420px;
    --h: 720px;
  }
  body{
    margin:0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
    background:#0f1115;
    color:#fff;
    display:flex;
    min-height:100svh;
    align-items:center;
    justify-content:center;
  }
  .wrap{
    width:min(var(--w), 100vw);
    padding:10px 10px 14px;
    box-sizing:border-box;
  }
  .hud{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin:6px 2px 10px;
    font-size:14px;
    opacity:.95;
  }
  .hud b{ font-size:16px; }
  .panel{
    background:#141824;
    border:1px solid rgba(255,255,255,.08);
    border-radius:14px;
    overflow:hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  canvas{
    width:100%;
    height:auto;
    display:block;
    background: radial-gradient(120% 80% at 50% 15%, rgba(255,255,255,.06), rgba(0,0,0,0) 50%),
                linear-gradient(#0f1320, #0b0d13);
    touch-action:manipulation;
  }
  .controls{
    display:flex;
    gap:10px;
    padding:10px;
    background: rgba(0,0,0,.18);
    border-top:1px solid rgba(255,255,255,.08);
  }
  button{
    flex:1;
    appearance:none;
    border:0;
    border-radius:12px;
    padding:14px 12px;
    font-weight:700;
    font-size:16px;
    color:#111;
    background:#ffd34d;
    cursor:pointer;
  }
  button.secondary{
    background:#2a3147;
    color:#fff;
    font-weight:600;
  }
  .toast{
    position:absolute;
    left:50%;
    top:18%;
    transform:translateX(-50%);
    background: rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.18);
    padding:10px 14px;
    border-radius:999px;
    font-weight:800;
    letter-spacing:.02em;
    opacity:0;
    transition: opacity .15s ease, transform .15s ease;
    pointer-events:none;
    white-space:nowrap;
  }
  .toast.show{
    opacity:1;
    transform:translateX(-50%) translateY(-2px);
  }
  .hint{
    font-size:12px;
    opacity:.75;
    margin-top:10px;
    line-height:1.5;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div>Score: <b id="score">0</b></div>
    <div>Best: <b id="best">0</b></div>
    <div id="state">READY</div>
  </div>

  <div class="panel" style="position:relative;">
    <div id="toast" class="toast">PERFECT!!</div>
    <canvas id="cv" width="420" height="720" aria-label="ãŸã“ç„¼ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼"></canvas>
    <div class="controls">
      <button id="stopBtn">STOPï¼ˆã‚¿ãƒƒãƒ—ï¼‰</button>
      <button id="restartBtn" class="secondary">RESTART</button>
    </div>
  </div>

  <div class="hint">
    ãƒ»æ“ä½œã¯ã€ŒSTOPã€ã ã‘ã€‚<br/>
    ãƒ»ä¸‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨é‡ãªã£ãŸåˆ†ã ã‘æ®‹ã‚Šã¾ã™ã€‚<br/>
    ãƒ»PERFECTï¼ˆã»ã¼åŒã˜ä½ç½®ï¼‰ã ã¨å‰Šã‚Œã¾ã›ã‚“ã€‚<br/>
  </div>
</div>


<script>
(() => {
  /* =========================================================
     âœ… ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼ï¼šæ•—å› è¡¨ç¤º + çµæœã‚³ãƒ”ãƒ¼ + ç§°å·ï¼ˆãŸã“ç„¼ããƒˆãƒ¬ã‚«é¢¨ï¼‰
     - é«˜ã•ãƒãƒ©ãƒãƒ©ã§ã‚‚ä¸Šã«é€²ã‚€ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ãƒ¡ãƒ©è¿½éšï¼‰
     - ãƒ¬ã‚¢åŠ¹æœï¼šé‡‘ç„¼ã(ç”˜åˆ¤å®š) / è™¹ä¼èª¬(1å›ä¿é™º) / æ¿€è¾›(é«˜é€Ÿ)
     - é€²æ—ï¼šFLOOR / METER
     - GAME OVERæ™‚ï¼šæ•—å› /ç§°å·/çµæœã‚³ãƒ”ãƒ¼ï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã§ãƒãƒ³ãƒƒï¼‰
     ========================================================= */

  // =========================
  // ç”»åƒï¼ˆãƒ‰ãƒƒãƒˆçµµï¼‰èª­ã¿è¾¼ã¿
  // =========================
  const SPR = {
    takoA: "https://YOUR-IMAGE-URL/takoA.png",
    takoB: "https://YOUR-IMAGE-URL/takoB.png",
    takoC: "https://YOUR-IMAGE-URL/takoC.png",
    takoG: "https://YOUR-IMAGE-URL/takoG.png", // é‡‘ç„¼ã
    takoR: "https://YOUR-IMAGE-URL/takoR.png", // æ¿€è¾›
    takoX: "https://YOUR-IMAGE-URL/takoX.png", // è™¹ä¼èª¬
  };

  const IMG = {};
  function loadImages(){
    const entries = Object.entries(SPR);
    let loaded = 0;
    return new Promise((resolve) => {
      if (!entries.length){ resolve(); return; }
      for (const [key, src] of entries){
        const im = new Image();
        im.crossOrigin = "anonymous";
        im.onload = () => { IMG[key] = im; loaded++; if (loaded === entries.length) resolve(); };
        im.onerror = () => { console.warn("Image load failed:", key, src); loaded++; if (loaded === entries.length) resolve(); };
        im.src = src;
      }
    });
  }

  // =========================
  // è¨­å®š
  // =========================
  const CONF = {
    canvasW: 420,
    canvasH: 720,

    baseWidth: 220,
    blockHDefault: 34,
    minWidth: 26,
    marginX: 16,

    speedBase: 2.6,
    speedPerLevel: 0.10,
    perfectPx: 3,

    grid: true,

    // âœ… é€²æ—å˜ä½
    PROGRESS_MODE: "FLOOR", // "FLOOR" or "METER"
    METER_PER_STANDARD_BLOCK: 0.7,
    METER_DECIMALS: 1,

    // âœ… ã‚«ãƒ¡ãƒ©
    CAMERA_ANCHOR_Y: 0.25,
    CAMERA_SMOOTH: 0.18,
    CAMERA_MIN: 0,

    // âœ… ç„¡é™ã§ã‚‚è»½ã
    KEEP_BLOCKS: 90, // 0ã§ç„¡åŠ¹

    // âœ… çµæœã‚³ãƒ”ãƒ¼ã®ãƒ†ãƒ³ãƒ—ãƒ¬ï¼ˆå¿…è¦ãªã‚‰åº—å/URLã‚’å·®ã—æ›¿ãˆï¼‰
    SHARE_HASHTAGS: "#ãŸã“ç„¼ããƒˆãƒ¬ã‚« #TakoyakiTower",
    SHARE_URL: "", // ä¾‹: "https://takoyaki-trc.github.io/..."ï¼ˆç©ºãªã‚‰å‡ºã•ãªã„ï¼‰
  };

  // =========================
  // ç¨®é¡ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆé«˜ã•å·®æ¿€ã—ã‚ï¼‰
  // =========================
  const BLOCK_TABLE = [
    { key:"takoA", w:45, h:18, label:"æ¥µè–„" },
    { key:"takoB", w:40, h:34, label:"æ¨™æº–" },
    { key:"takoC", w:28, h:58, label:"å±±ç››ã‚Š" },

    { key:"takoG", w:8,  h:26, label:"é‡‘ç„¼ã", perfectPlus: 3 },
    { key:"takoR", w:6,  h:70, label:"æ¿€è¾›",   speedMul: 1.25 },
    { key:"takoX", w:2,  h:92, label:"è™¹ä¼èª¬", insurance: true },
  ];

  let lastKey = null;
  function pickBlockDef(){
    if (BLOCK_TABLE.length <= 1) return BLOCK_TABLE[0];
    let total = 0; for (const d of BLOCK_TABLE) total += d.w;

    for (let tries=0; tries<6; tries++){
      let r = Math.random() * total;
      for (const d of BLOCK_TABLE){
        r -= d.w;
        if (r <= 0){
          if (d.key === lastKey) break;
          lastKey = d.key;
          return d;
        }
      }
    }
    const fb = BLOCK_TABLE[Math.floor(Math.random()*BLOCK_TABLE.length)];
    lastKey = fb.key;
    return fb;
  }

  // =========================
  // DOM
  // =========================
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const stateEl = document.getElementById("state");
  const toastEl = document.getElementById("toast");
  const stopBtn = document.getElementById("stopBtn");
  const restartBtn = document.getElementById("restartBtn");

  cv.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    if (!S.playing) start();
    else drop();
  }, { passive:false });

  stopBtn.addEventListener("click", () => {
    if (!S.playing) start();
    else drop();
  });

  restartBtn.addEventListener("click", reset);

  // =========================
  // ä¿å­˜ï¼ˆãƒ™ã‚¹ãƒˆï¼‰
  // =========================
  const BEST_KEY = `takoyakiTimingTower_best_${CONF.PROGRESS_MODE}`;
  function loadBest(){
    const v = Number(localStorage.getItem(BEST_KEY) || 0);
    return Number.isFinite(v) ? v : 0;
  }
  function saveBest(v){
    localStorage.setItem(BEST_KEY, String(v));
  }

  // =========================
  // çŠ¶æ…‹
  // =========================
  const S = {
    playing: false,
    over: false,

    progress: 0,
    best: loadBest(),

    level: 0,
    cameraY: 0,
    dir: 1,

    blocks: [],
    curr: null,

    // çµæœç”¨
    lastRunProgress: 0,
    lastFailReason: "",
    lastFailDetail: "",
    lastTitle: "",
    lastSubtitle: "",
    lastLastBlockLabel: "", // æœ€å¾Œã«ç½®ã‘ãŸãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡
    lastUsedSpecials: [],   // é‡‘/è™¹/æ¿€è¾›ãŒå‡ºãŸè¨˜éŒ²ï¼ˆè¡¨ç¤ºç”¨ï¼‰
  };

  // =========================
  // UIï¼ˆãƒˆãƒ¼ã‚¹ãƒˆï¼‰
  // =========================
  function showToast(text){
    toastEl.textContent = text;
    toastEl.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove("show"), 520);
  }

  function formatProgress(v){
    if (CONF.PROGRESS_MODE === "METER") return `${v.toFixed(CONF.METER_DECIMALS)}m`;
    return `${Math.floor(v)}F`;
  }

  function setHUD(){
    scoreEl.textContent = formatProgress(S.progress);
    bestEl.textContent  = formatProgress(S.best);
    stateEl.textContent = S.over ? "GAME OVER" : (S.playing ? "PLAYING" : "READY");
  }

  // =========================
  // ç§°å·ï¼ˆãŸã“ç„¼ããƒˆãƒ¬ã‚«é¢¨ï¼‰
  // =========================
  function getTakoyakiTitle(progress){
    // é€²æ—ã®â€œæ®µéšâ€ã‚’ä½œã‚‹ï¼ˆFLOORå„ªå…ˆã§åˆ»ã¿ã‚„ã™ã„ï¼‰
    const p = (CONF.PROGRESS_MODE === "FLOOR") ? Math.floor(progress) : progress;

    // ãŸã“ç„¼ããƒˆãƒ¬ã‚«ã£ã½ã„ã€Œç§°å·ã€ï¼‹ã‚µãƒ–ã‚³ãƒ”ãƒ¼
    // â€»å¥½ãã«å¢—ã‚„ã—ã¦OK
    const table = (CONF.PROGRESS_MODE === "FLOOR")
      ? [
          { min: 0,   title:"ã€˜æœªæŠ•å…¥ã€™",           sub:"é‰„æ¿ã«ã€ç½®ã‹ã‚Œã¦ã„ãªã„ã€‚" },
          { min: 1,   title:"ã€˜åˆç„¼ãè¦‹ç¿’ã„ã€™",     sub:"ä¸¸ãã™ã‚‹å‰ã«ã€å¿ƒãŒæºã‚Œã‚‹ã€‚" },
          { min: 5,   title:"ã€˜è¿”ã—ã®å°æ‰‹å…ˆã€™",     sub:"è§’åº¦ã ã‘ä¸Šæ‰‹ã„ã€‚ã¾ã æµ…ã„ã€‚" },
          { min: 10,  title:"ã€˜æ¹¯æ°—ã®è¦³æ¸¬è€…ã€™",     sub:"ç†±ã¯è¦‹ãˆã‚‹ã€‚ã ãŒè€æ€§ã¯ãªã„ã€‚" },
          { min: 15,  title:"ã€˜ç„¼ãç¸®ã¿ã®é”äººã€™",   sub:"å°ã•ããªã£ã¦ã‚‚ã€è«¦ã‚ãªã„ã€‚" },
          { min: 20,  title:"ã€˜é‰„æ¿ã®ä¸­ç´šè€…ã€™",     sub:"ç„¦ã’ã¨ä¼šè©±ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚" },
          { min: 30,  title:"ã€˜ã‚¿ã‚³æ°‘ã®è©•è­°å“¡ã€™",   sub:"ç©ã‚€ã“ã¨ã¯ã€è¡—ã‚’å®ˆã‚‹ã“ã¨ã€‚" },
          { min: 40,  title:"ã€˜è·äººç¥­å£‡ã®å€™è£œè€…ã€™", sub:"ç¥­å£‡ãŒã€å›ã®æ‰‹å…ƒã‚’è¦‹ã¦ã„ã‚‹ã€‚" },
          { min: 50,  title:"ã€˜é‡‘æ ã®ç„¼ãæ‰‹ã€™",     sub:"PERFECTã®åŒ‚ã„ãŒã™ã‚‹ã€‚" },
          { min: 70,  title:"ã€˜ä¼èª¬ã®è¿”ã—ã€™",       sub:"è½ã¡ãªã„ã®ã§ã¯ãªã„ã€‚è½ã¨ã•ãªã„ã€‚" },
          { min: 100, title:"ã€˜ç„¼ã‹ã‚ŒãŸä¼èª¬ã€™",     sub:"å›ã®å¡”ãŒã€ã‚«ãƒ¼ãƒ‰ã«ãªã‚‹ã€‚" },
          { min: 130, title:"ã€˜ç¦æ–­ã®å¤šæ®µè¿”ã—ã€™",   sub:"èª°ã‚‚çœŸä¼¼ã§ããªã„é€Ÿåº¦åŸŸã€‚" },
          { min: 160, title:"ã€˜é‰„æ¿ã®å‘ã“ã†å´ã€™",   sub:"ä¸Šé™ã¯ã€å›ãŒæ±ºã‚ã‚‹ã€‚" },
          { min: 200, title:"ã€˜ç¥è©±ç´šãƒ»ä¸¸ã®æ”¯é…è€…ã€™",sub:"ã“ã“ã¾ã§æ¥ã‚‹ã¨ã€æ€–ã„ã€‚" },
        ]
      : [
          { min: 0,    title:"ã€˜æœªæŠ•å…¥ã€™",           sub:"é‰„æ¿ã«ã€ç½®ã‹ã‚Œã¦ã„ãªã„ã€‚" },
          { min: 1.0,  title:"ã€˜åˆç„¼ãè¦‹ç¿’ã„ã€™",     sub:"é«˜ã•ã‚ˆã‚Šã€æ‰‹ãŒéœ‡ãˆã‚‹ã€‚" },
          { min: 5.0,  title:"ã€˜æ¹¯æ°—ã®è¦³æ¸¬è€…ã€™",     sub:"ç†±ã¯è¦‹ãˆã‚‹ã€‚ã ãŒè€æ€§ã¯ãªã„ã€‚" },
          { min: 10.0, title:"ã€˜é‰„æ¿ã®ä¸­ç´šè€…ã€™",     sub:"ç„¦ã’ã¨ä¼šè©±ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã€‚" },
          { min: 15.0, title:"ã€˜è·äººç¥­å£‡ã®å€™è£œè€…ã€™", sub:"ç¥­å£‡ãŒã€å›ã®æ‰‹å…ƒã‚’è¦‹ã¦ã„ã‚‹ã€‚" },
          { min: 25.0, title:"ã€˜ç„¼ã‹ã‚ŒãŸä¼èª¬ã€™",     sub:"å›ã®å¡”ãŒã€ã‚«ãƒ¼ãƒ‰ã«ãªã‚‹ã€‚" },
          { min: 35.0, title:"ã€˜ç¦æ–­ã®å¤šæ®µè¿”ã—ã€™",   sub:"èª°ã‚‚çœŸä¼¼ã§ããªã„é€Ÿåº¦åŸŸã€‚" },
          { min: 50.0, title:"ã€˜ç¥è©±ç´šãƒ»ä¸¸ã®æ”¯é…è€…ã€™",sub:"ã“ã“ã¾ã§æ¥ã‚‹ã¨ã€æ€–ã„ã€‚" },
        ];

    // æœ€å¤§minã‚’æº€ãŸã™ã‚‚ã®ã‚’é¸ã¶
    let pick = table[0];
    for (const row of table){
      if (p >= row.min) pick = row;
    }
    return pick;
  }

  // =========================
  // çµæœã‚³ãƒ”ãƒ¼ç”¨ï¼ˆãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆï¼‰
  // =========================
  function buildShareText(){
    const title = S.lastTitle || "ã€˜ç„¼ãçµæœã€™";
    const reached = formatProgress(S.lastRunProgress);
    const best = formatProgress(S.best);
    const reason = S.lastFailReason ? `æ•—å› ï¼š${S.lastFailReason}` : "";
    const detail = S.lastFailDetail ? `ï¼ˆ${S.lastFailDetail}ï¼‰` : "";
    const lastBlock = S.lastLastBlockLabel ? `æœ€å¾Œã®ç„¼ãï¼š${S.lastLastBlockLabel}` : "";

    const specials = S.lastUsedSpecials.length ? `å‡ºç¾ï¼š${S.lastUsedSpecials.join(" / ")}` : "";
    const url = CONF.SHARE_URL ? `\n${CONF.SHARE_URL}` : "";

    const lines = [
      "ã€ãŸã“ç„¼ãã‚¿ãƒ¯ãƒ¼ã€‘",
      `${title}`,
      `åˆ°é”ï¼š${reached} / BESTï¼š${best}`,
      (reason + detail).trim(),
      lastBlock,
      specials,
      CONF.SHARE_HASHTAGS
    ].filter(Boolean);

    return lines.join("\n") + url;
  }

  async function copyToClipboard(text){
    try{
      if (navigator.clipboard && window.isSecureContext){
        await navigator.clipboard.writeText(text);
        return true;
      }
    }catch(e){}
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    try{
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.top = "0";
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, ta.value.length);
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    }catch(e){}
    return false;
  }

  // =========================
  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®â€œãƒãƒ³ã£â€ï¼‰
  // =========================
  let resultOverlay = null;

  function ensureOverlay(){
    if (resultOverlay) return resultOverlay;

    const wrap = cv.closest(".panel") || document.body;

    const box = document.createElement("div");
    box.id = "takoyakiResultOverlay";
    box.style.position = "absolute";
    box.style.left = "0";
    box.style.top = "0";
    box.style.width = "100%";
    box.style.height = "100%";
    box.style.display = "none";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.zIndex = "9999";
    box.style.pointerEvents = "auto";

    // èƒŒæ™¯
    const bg = document.createElement("div");
    bg.style.position = "absolute";
    bg.style.inset = "0";
    bg.style.background = "rgba(0,0,0,.72)";
    bg.style.backdropFilter = "blur(2px)";
    bg.style.webkitBackdropFilter = "blur(2px)";
    box.appendChild(bg);

    // ã‚«ãƒ¼ãƒ‰é¢¨ãƒ‘ãƒãƒ«
    const card = document.createElement("div");
    card.style.position = "relative";
    card.style.width = "min(92%, 420px)";
    card.style.borderRadius = "18px";
    card.style.border = "1px solid rgba(255,255,255,.18)";
    card.style.background = "linear-gradient(180deg, rgba(24,28,40,.95), rgba(12,14,20,.95))";
    card.style.boxShadow = "0 20px 60px rgba(0,0,0,.55)";
    card.style.padding = "16px 14px";
    card.style.boxSizing = "border-box";
    card.style.transform = "translateY(6px) scale(.98)";
    card.style.opacity = "0";
    card.style.transition = "transform .18s ease, opacity .18s ease";
    box.appendChild(card);

    // ã‚¿ã‚¤ãƒˆãƒ«
    const h1 = document.createElement("div");
    h1.id = "resTitle";
    h1.style.fontWeight = "900";
    h1.style.fontSize = "18px";
    h1.style.letterSpacing = ".02em";
    h1.style.marginBottom = "6px";
    card.appendChild(h1);

    // ã‚µãƒ–
    const sub = document.createElement("div");
    sub.id = "resSub";
    sub.style.opacity = ".85";
    sub.style.fontSize = "13px";
    sub.style.lineHeight = "1.35";
    sub.style.marginBottom = "10px";
    card.appendChild(sub);

    // åˆ°é”ï¼†ãƒ™ã‚¹ãƒˆ
    const stats = document.createElement("div");
    stats.id = "resStats";
    stats.style.display = "grid";
    stats.style.gridTemplateColumns = "1fr 1fr";
    stats.style.gap = "10px";
    stats.style.marginBottom = "10px";
    card.appendChild(stats);

    const statA = document.createElement("div");
    statA.style.padding = "10px";
    statA.style.borderRadius = "14px";
    statA.style.border = "1px solid rgba(255,255,255,.12)";
    statA.style.background = "rgba(255,255,255,.06)";
    statA.innerHTML = `<div style="opacity:.75;font-size:12px;">åˆ°é”</div><div id="resReach" style="font-weight:900;font-size:20px;margin-top:2px;"></div>`;
    stats.appendChild(statA);

    const statB = document.createElement("div");
    statB.style.padding = "10px";
    statB.style.borderRadius = "14px";
    statB.style.border = "1px solid rgba(255,255,255,.12)";
    statB.style.background = "rgba(255,255,255,.06)";
    statB.innerHTML = `<div style="opacity:.75;font-size:12px;">BEST</div><div id="resBest" style="font-weight:900;font-size:20px;margin-top:2px;"></div>`;
    stats.appendChild(statB);

    // æ•—å› 
    const fail = document.createElement("div");
    fail.id = "resFail";
    fail.style.padding = "10px";
    fail.style.borderRadius = "14px";
    fail.style.border = "1px solid rgba(255,255,255,.12)";
    fail.style.background = "rgba(255,255,255,.04)";
    fail.style.marginBottom = "10px";
    fail.style.fontSize = "13px";
    fail.style.lineHeight = "1.4";
    card.appendChild(fail);

    // ç‰¹è¨˜äº‹é …
    const extra = document.createElement("div");
    extra.id = "resExtra";
    extra.style.opacity = ".85";
    extra.style.fontSize = "12px";
    extra.style.lineHeight = "1.35";
    extra.style.marginBottom = "12px";
    card.appendChild(extra);

    // ãƒœã‚¿ãƒ³åˆ—
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "10px";
    card.appendChild(row);

    const copyBtn = document.createElement("button");
    copyBtn.id = "resCopyBtn";
    copyBtn.type = "button";
    copyBtn.textContent = "çµæœã‚’ã‚³ãƒ”ãƒ¼";
    copyBtn.style.flex = "1";
    copyBtn.style.border = "0";
    copyBtn.style.borderRadius = "14px";
    copyBtn.style.padding = "14px 12px";
    copyBtn.style.fontWeight = "900";
    copyBtn.style.background = "#ffd34d";
    copyBtn.style.color = "#111";
    copyBtn.style.cursor = "pointer";
    row.appendChild(copyBtn);

    const againBtn = document.createElement("button");
    againBtn.type = "button";
    againBtn.textContent = "ã‚‚ã†ä¸€å›";
    againBtn.style.flex = "1";
    againBtn.style.border = "0";
    againBtn.style.borderRadius = "14px";
    againBtn.style.padding = "14px 12px";
    againBtn.style.fontWeight = "800";
    againBtn.style.background = "#2a3147";
    againBtn.style.color = "#fff";
    againBtn.style.cursor = "pointer";
    row.appendChild(againBtn);

    // ã‚¤ãƒ™ãƒ³ãƒˆ
    copyBtn.addEventListener("click", async () => {
      const text = buildShareText();
      const ok = await copyToClipboard(text);
      showToast(ok ? "ã‚³ãƒ”ãƒ¼ã—ãŸï¼" : "ã‚³ãƒ”ãƒ¼å¤±æ•—ï¼ˆæ‰‹å‹•ã§é¸æŠã—ã¦ã­ï¼‰");
      // å¤±æ•—æ™‚ã®ãŸã‚ã«ã€ãƒ†ã‚­ã‚¹ãƒˆã‚‚ä¸€ç¬å‡ºã™
      if (!ok){
        alert(text);
      }
    });

    againBtn.addEventListener("click", () => {
      hideResultOverlay();
      reset();
      start();
    });

    // èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹ï¼ˆä»»æ„ï¼šæ¶ˆã—ãŸã‘ã‚Œã°ã“ã“ã‚’å¤–ã™ï¼‰
    bg.addEventListener("click", () => {
      hideResultOverlay();
    });

    // panelãŒposition:relativeå‰æã ã‘ã©ã€ç„¡ã‘ã‚Œã°è¶³ã™
    const st = getComputedStyle(wrap);
    if (st.position === "static") wrap.style.position = "relative";
    wrap.appendChild(box);

    resultOverlay = { box, card };
    return resultOverlay;
  }

  function showResultOverlay(){
    const o = ensureOverlay();
    // å†…å®¹åæ˜ 
    const title = S.lastTitle || "ã€˜ç„¼ãçµæœã€™";
    const sub = S.lastSubtitle || "";
    const reached = formatProgress(S.lastRunProgress);
    const best = formatProgress(S.best);

    const specials = S.lastUsedSpecials.length ? `å‡ºç¾ï¼š${S.lastUsedSpecials.join(" / ")}` : "å‡ºç¾ï¼šãªã—";
    const lastBlock = S.lastLastBlockLabel ? `æœ€å¾Œã®ç„¼ãï¼š${S.lastLastBlockLabel}` : "æœ€å¾Œã®ç„¼ãï¼šâ€”";

    document.getElementById("resTitle").textContent = title;
    document.getElementById("resSub").textContent = sub;
    document.getElementById("resReach").textContent = reached;
    document.getElementById("resBest").textContent = best;

    const reason = S.lastFailReason || "ä¸æ˜";
    const detail = S.lastFailDetail ? `ï¼ˆ${S.lastFailDetail}ï¼‰` : "";
    document.getElementById("resFail").innerHTML =
      `<div style="opacity:.75;font-size:12px;margin-bottom:4px;">æ•—å› </div>` +
      `<div style="font-weight:900;">${escapeHtml(reason)} ${escapeHtml(detail)}</div>`;

    document.getElementById("resExtra").textContent = `${lastBlock} / ${specials}`;

    // è¡¨ç¤º
    o.box.style.display = "flex";
    requestAnimationFrame(() => {
      o.card.style.opacity = "1";
      o.card.style.transform = "translateY(0) scale(1)";
    });
  }

  function hideResultOverlay(){
    if (!resultOverlay) return;
    const { box, card } = resultOverlay;
    card.style.opacity = "0";
    card.style.transform = "translateY(6px) scale(.98)";
    setTimeout(() => {
      box.style.display = "none";
    }, 180);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
    }[c]));
  }

  // =========================
  // ãƒ–ãƒ­ãƒƒã‚¯
  // =========================
  function makeBlock({ x, width, y, h, tileKey, label="", perfectPlus=0, speedMul=1, insurance=false }){
    return { x, width, y, h, tileKey, label, perfectPlus, speedMul, insurance };
  }

  function spawnBase(){
    const def = pickBlockDef();
    const w = CONF.baseWidth;
    const x = (CONF.canvasW - w) / 2;
    const y = CONF.canvasH - 90;

    const base = makeBlock({
      x, width: w, y,
      h: def.h ?? CONF.blockHDefault,
      tileKey: def.key,
      label: def.label || "",
      perfectPlus: def.perfectPlus || 0,
      speedMul: def.speedMul || 1,
      insurance: !!def.insurance
    });

    S.blocks = [base];
    S.level = 1;
  }

  function spawnCurrent(){
    const prev = S.blocks[S.blocks.length - 1];
    const def = pickBlockDef();

    const w = prev.width;
    const h = def.h ?? CONF.blockHDefault;
    const y = prev.y - h;

    const startLeft = (S.level % 2 === 0);
    const x = startLeft ? CONF.marginX : (CONF.canvasW - CONF.marginX - w);
    S.dir = startLeft ? 1 : -1;

    S.curr = makeBlock({
      x, width: w, y,
      h,
      tileKey: def.key,
      label: def.label || "",
      perfectPlus: def.perfectPlus || 0,
      speedMul: def.speedMul || 1,
      insurance: !!def.insurance
    });

    // ç‰¹æ®Šå‡ºç¾ãƒ­ã‚°ï¼ˆçµæœç”¨ï¼‰
    if (S.curr.insurance) S.lastUsedSpecials.push("è™¹ä¼èª¬");
    else if ((S.curr.perfectPlus||0) > 0) S.lastUsedSpecials.push("é‡‘ç„¼ã");
    else if ((S.curr.speedMul||1) > 1) S.lastUsedSpecials.push("æ¿€è¾›");

    // ãƒˆãƒ¼ã‚¹ãƒˆ
    if (S.curr.insurance) showToast("ğŸŒˆ è™¹ä¼èª¬ï¼šä¿é™ºä»˜ãï¼");
    else if ((S.curr.perfectPlus||0) > 0) showToast("ğŸ¥‡ é‡‘ç„¼ãï¼šç”˜åˆ¤å®šï¼");
    else if ((S.curr.speedMul||1) > 1) showToast("ğŸŒ¶ æ¿€è¾›ï¼šé«˜é€Ÿï¼");
  }

  // =========================
  // é€²æ—ï¼ˆéš / ãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
  // =========================
  function computeProgress(){
    const floors = Math.max(0, S.blocks.length - 1);
    if (CONF.PROGRESS_MODE === "FLOOR") return floors;

    let sum = 0;
    for (let i=1; i<S.blocks.length; i++){
      const b = S.blocks[i];
      sum += (b.h / 34) * CONF.METER_PER_STANDARD_BLOCK;
    }
    return sum;
  }

  // =========================
  // ã‚«ãƒ¡ãƒ©è¿½éšï¼ˆæ­¢ã¾ã‚‰ãªã„ï¼‰
  // =========================
  function getTopMostY(){
    let topY = Infinity;
    for (const b of S.blocks){
      if (Number.isFinite(b.y)) topY = Math.min(topY, b.y);
    }
    if (S.curr && Number.isFinite(S.curr.y)) topY = Math.min(topY, S.curr.y);
    if (!Number.isFinite(topY)) topY = 0;
    return topY;
  }

  function updateCamera(){
    const topY = getTopMostY();
    const anchorY = CONF.canvasH * CONF.CAMERA_ANCHOR_Y;
    const target = Math.max(CONF.CAMERA_MIN, anchorY - topY);
    S.cameraY += (target - S.cameraY) * CONF.CAMERA_SMOOTH;
  }

  // =========================
  // ã‚²ãƒ¼ãƒ 
  // =========================
  function reset(){
    hideResultOverlay();

    S.playing = false;
    S.over = false;

    S.progress = 0;
    S.lastRunProgress = 0;
    S.lastFailReason = "";
    S.lastFailDetail = "";
    S.lastTitle = "";
    S.lastSubtitle = "";
    S.lastLastBlockLabel = "";
    S.lastUsedSpecials = [];

    S.cameraY = 0;
    S.dir = 1;

    spawnBase();
    spawnCurrent();

    S.progress = computeProgress();
    setHUD();
    draw();
  }

  function start(){
    if (S.over) reset();
    S.playing = true;
    setHUD();
  }

  function levelSpeed(){
    const base = CONF.speedBase + S.level * CONF.speedPerLevel;
    const mul = (S.curr && S.curr.speedMul) ? S.curr.speedMul : 1;
    return base * mul;
  }

  function endRun(){
    S.lastRunProgress = S.progress;

    // ç§°å·æ±ºå®š
    const t = getTakoyakiTitle(S.lastRunProgress);
    S.lastTitle = t.title;
    S.lastSubtitle = t.sub;

    // ãƒ™ã‚¹ãƒˆæ›´æ–°ã¯æ—¢ã«é€”ä¸­ã§ã‚„ã‚‹ãŒã€ä¿é™ºã¨ã—ã¦
    if (S.progress > S.best){
      S.best = S.progress;
      saveBest(S.best);
    }

    setHUD();
    showResultOverlay();
  }

  function gameOver(reason, detail){
    S.over = true;
    S.playing = false;

    S.lastFailReason = reason || "ç„¼ãå¤±æ•—";
    S.lastFailDetail = detail || "";

    showToast("ç„¼ãå¤±æ•—â€¦ GAME OVER");
    endRun();
  }

  function drop(){
    if (!S.curr || S.over) return;

    const prev = S.blocks[S.blocks.length - 1];
    const curr = S.curr;

    const overlapLeft  = Math.max(prev.x, curr.x);
    const overlapRight = Math.min(prev.x + prev.width, curr.x + curr.width);
    const overlapW = overlapRight - overlapLeft;

    // â‘  å¤–ã‚ŒãŸï¼ˆé‡ãªã‚Š0ï¼‰
    if (overlapW <= 0){
      S.progress = computeProgress();
      gameOver("å¤–ã‚ŒãŸï¼ˆé‡ãªã‚Šã‚¼ãƒ­ï¼‰", "ãŸã“ç„¼ããŒé‰„æ¿ã‹ã‚‰é€ƒã’ãŸ");
      return;
    }

    const diff = Math.abs(curr.x - prev.x);
    const perfectRange = CONF.perfectPx + (curr.perfectPlus || 0);
    const isPerfect = diff <= perfectRange;
    const willShrink = overlapW < curr.width;

    // è™¹ä¼èª¬ï¼š1å›ã ã‘å‰Šã‚Œãªã„
    if (curr.insurance && willShrink){
      curr.x = overlapLeft;
      // widthç¶­æŒ
      curr.insurance = false;
      showToast("ğŸŒˆ è™¹ä¼èª¬ç™ºå‹•ï¼šã‚»ãƒ¼ãƒ•ï¼");
    } else if (isPerfect){
      curr.x = prev.x;
      curr.width = prev.width;
      showToast("PERFECT!!");
    } else {
      curr.x = overlapLeft;
      curr.width = overlapW;
    }

    // ç¢ºå®š
    S.blocks.push(curr);
    S.lastLastBlockLabel = curr.label || ""; // æœ€å¾Œã«ç½®ã‘ãŸãƒ–ãƒ­ãƒƒã‚¯

    S.curr = null;

    // ç„¡é™è»½é‡åŒ–
    if (CONF.KEEP_BLOCKS > 0 && S.blocks.length > CONF.KEEP_BLOCKS){
      S.blocks = S.blocks.slice(S.blocks.length - CONF.KEEP_BLOCKS);
    }

    // æ¬¡ã®æ®µã¸
    S.level++;

    // é€²æ—æ›´æ–°
    S.progress = computeProgress();

    // ãƒ™ã‚¹ãƒˆæ›´æ–°
    if (S.progress > S.best){
      S.best = S.progress;
      saveBest(S.best);
    }

    // â‘¡ ç„¼ãç¸®ã¿ï¼ˆå¹…ãŒé™ç•Œä»¥ä¸‹ï¼‰â†’ç½®ã‘ãŸã‘ã©æ¬¡ãŒç„¡ç†
    if (curr.width < CONF.minWidth){
      gameOver("ç„¼ãç¸®ã¿ï¼ˆå¹…ãŒé™ç•Œï¼‰", `æ®‹ã‚Šå¹… ${Math.floor(curr.width)}px / é™ç•Œ ${CONF.minWidth}px`);
      return;
    }

    spawnCurrent();
    setHUD();
  }

  function update(){
    if (S.playing && !S.over && S.curr){
      const sp = levelSpeed();
      S.curr.x += sp * S.dir;

      const minX = CONF.marginX;
      const maxX = CONF.canvasW - CONF.marginX - S.curr.width;

      if (S.curr.x <= minX){
        S.curr.x = minX;
        S.dir = 1;
      } else if (S.curr.x >= maxX){
        S.curr.x = maxX;
        S.dir = -1;
      }
    }

    if (!S.over) updateCamera();
  }

  // =========================
  // æç”»
  // =========================
  function drawBG(){
    if (!CONF.grid) return;
    ctx.save();
    ctx.globalAlpha = 0.12;
    const step = 30;
    for (let y=0; y<CONF.canvasH; y+=step){
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(CONF.canvasW,y);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  }

  function roundedPath(x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function roundRect(x, y, w, h, r, fillStyle){
    ctx.save();
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    roundedPath(x, y, w, h, r);
    ctx.fill();
    ctx.restore();
  }

  function drawBlock(b){
    const y = b.y + S.cameraY;
    if (y > CONF.canvasH + 120 || y < -240) return;

    const x = Math.round(b.x);
    const w = Math.round(b.width);
    const h = Math.round(b.h);
    const r = Math.max(6, Math.round(h * 0.22));

    const tile = b.tileKey ? IMG[b.tileKey] : null;

    if (!tile || !tile.naturalWidth){
      const grad = ctx.createLinearGradient(x, y, x, y+h);
      grad.addColorStop(0, "#ffd34d");
      grad.addColorStop(1, "#f08b2f");
      roundRect(x, y, w, h, r, grad);
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,.45)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      roundedPath(x, y, w, h, r);
      ctx.stroke();
      ctx.restore();
      return;
    }

    const scale = h / tile.naturalHeight;
    const tileW = Math.max(1, Math.round(tile.naturalWidth * scale));

    ctx.save();
    ctx.beginPath();
    roundedPath(x, y, w, h, r);
    ctx.clip();

    for (let xx = x; xx < x + w; xx += tileW){
      ctx.drawImage(tile, xx, y, tileW, h);
    }

    ctx.restore();

    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,.45)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    roundedPath(x, y, w, h, r);
    ctx.stroke();
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,CONF.canvasW, CONF.canvasH);
    ctx.imageSmoothingEnabled = false;

    drawBG();

    for (const b of S.blocks) drawBlock(b);
    if (S.curr) drawBlock(S.curr);

    // HUDã£ã½ã„æƒ…å ±ï¼ˆå·¦ä¸Šï¼‰
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#fff";
    ctx.font = "700 12px system-ui, sans-serif";
    ctx.fillText(`ç¾åœ¨: ${formatProgress(S.progress)} / BEST: ${formatProgress(S.best)}`, 14, 24);
    ctx.restore();
  }

  // =========================
  // ãƒ«ãƒ¼ãƒ—
  // =========================
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // =========================
  // åˆæœŸåŒ–
  // =========================
  loadImages().then(() => {
    reset();
    loop();
  });
})();
</script>





  

</body>
</html>

