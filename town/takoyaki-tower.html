
<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
<title>ãŸã“ç„¼ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼</title>
<style>
  :root{
    --w: 420px;
    --h: 720px;
  }
  body{
    margin:0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
    background:#0f1115;
    color:#fff;
    display:flex;
    min-height:100svh;
    align-items:center;
    justify-content:center;
  }
  .wrap{
    width:min(var(--w), 100vw);
    padding:10px 10px 14px;
    box-sizing:border-box;
  }
  .hud{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin:6px 2px 10px;
    font-size:14px;
    opacity:.95;
  }
  .hud b{ font-size:16px; }
  .panel{
    background:#141824;
    border:1px solid rgba(255,255,255,.08);
    border-radius:14px;
    overflow:hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  canvas{
    width:100%;
    height:auto;
    display:block;
    background: radial-gradient(120% 80% at 50% 15%, rgba(255,255,255,.06), rgba(0,0,0,0) 50%),
                linear-gradient(#0f1320, #0b0d13);
    touch-action:manipulation;
  }
  .controls{
    display:flex;
    gap:10px;
    padding:10px;
    background: rgba(0,0,0,.18);
    border-top:1px solid rgba(255,255,255,.08);
  }
  button{
    flex:1;
    appearance:none;
    border:0;
    border-radius:12px;
    padding:14px 12px;
    font-weight:700;
    font-size:16px;
    color:#111;
    background:#ffd34d;
    cursor:pointer;
  }
  button.secondary{
    background:#2a3147;
    color:#fff;
    font-weight:600;
  }
  .toast{
    position:absolute;
    left:50%;
    top:18%;
    transform:translateX(-50%);
    background: rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.18);
    padding:10px 14px;
    border-radius:999px;
    font-weight:800;
    letter-spacing:.02em;
    opacity:0;
    transition: opacity .15s ease, transform .15s ease;
    pointer-events:none;
    white-space:nowrap;
  }
  .toast.show{
    opacity:1;
    transform:translateX(-50%) translateY(-2px);
  }
  .hint{
    font-size:12px;
    opacity:.75;
    margin-top:10px;
    line-height:1.5;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div>Score: <b id="score">0</b></div>
    <div>Best: <b id="best">0</b></div>
    <div id="state">READY</div>
  </div>

  <div class="panel" style="position:relative;">
    <div id="toast" class="toast">PERFECT!!</div>
    <canvas id="cv" width="420" height="720" aria-label="ãŸã“ç„¼ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼"></canvas>
    <div class="controls">
      <button id="stopBtn">STOPï¼ˆã‚¿ãƒƒãƒ—ï¼‰</button>
      <button id="restartBtn" class="secondary">RESTART</button>
    </div>
  </div>

  <div class="hint">
    ãƒ»æ“ä½œã¯ã€ŒSTOPã€ã ã‘ã€‚<br/>
    ãƒ»ä¸‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨é‡ãªã£ãŸåˆ†ã ã‘æ®‹ã‚Šã¾ã™ã€‚<br/>
    ãƒ»PERFECTï¼ˆã»ã¼åŒã˜ä½ç½®ï¼‰ã ã¨å‰Šã‚Œã¾ã›ã‚“ã€‚<br/>
  </div>
</div>

<script>
(() => {
  /* =========================================================
     âœ… ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼ï¼ˆç”»åƒã‚¿ã‚¤ãƒ«å¯¾å¿œ + ãƒ¬ã‚¢åŠ¹æœ + é€²æ—ã‚’éš/ãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
     - ç‰©ç†ãªã— / åº§æ¨™è¨ˆç®—ã®ã¿
     - ãƒ–ãƒ­ãƒƒã‚¯ç¨®é¡ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆç”»åƒã‚¿ã‚¤ãƒ«è¤‡æ•°ï¼‰
     - ãƒ¬ã‚¢åŠ¹æœï¼š
       é‡‘ç„¼ãï¼šPERFECTåˆ¤å®š +2pxï¼ˆç”˜ãï¼‰
       è™¹ä¼èª¬ï¼š1å›ã ã‘å‰Šã‚Œãªã„ä¿é™ºï¼ˆæ¶ˆè²»ï¼‰
       æ¿€è¾›ï¼šç§»å‹•é€Ÿåº¦UPï¼ˆãƒã‚¤ãƒªã‚¹ã‚¯ï¼‰
     - é€²æ—ï¼ˆScoreï¼‰ã‚’ç‚¹æ•°ã§ã¯ãªãã€ŒFLOOR / METERã€ã«å¤‰æ›´
     ========================================================= */

  // =========================
  // 1) ç”»åƒï¼ˆãƒ‰ãƒƒãƒˆçµµï¼‰èª­ã¿è¾¼ã¿
  // =========================
  // â˜…ã“ã“ã‚’ã‚ãªãŸã®ç”»åƒURLã«å·®ã—æ›¿ãˆ
  // é€éPNGæ¨å¥¨ / æ¨ªã«æ•·ãè©°ã‚å¯èƒ½ãªã‚¿ã‚¤ãƒ«ç”»åƒã ã¨æœ€é«˜
  const SPR = {
    takoA: "https://YOUR-IMAGE-URL/takoA.png",
    takoB: "https://YOUR-IMAGE-URL/takoB.png",
    takoC: "https://YOUR-IMAGE-URL/takoC.png",
    takoG: "https://YOUR-IMAGE-URL/takoG.png", // é‡‘ç„¼ã
    takoR: "https://YOUR-IMAGE-URL/takoR.png", // æ¿€è¾›
    takoX: "https://YOUR-IMAGE-URL/takoX.png", // è™¹ä¼èª¬
  };

  const IMG = {};

  function loadImages(){
    const entries = Object.entries(SPR);
    let loaded = 0;

    return new Promise((resolve) => {
      if (!entries.length){ resolve(); return; }
      for (const [key, src] of entries){
        const im = new Image();
        im.crossOrigin = "anonymous"; // GitHubç­‰ã§å¿…è¦ãªã“ã¨ãŒã‚ã‚‹
        im.onload = () => {
          IMG[key] = im;
          loaded++;
          if (loaded === entries.length) resolve();
        };
        im.onerror = () => {
          console.warn("Image load failed:", key, src);
          loaded++;
          if (loaded === entries.length) resolve(); // å¤±æ•—ã—ã¦ã‚‚fallbackã§å‹•ã
        };
        im.src = src;
      }
    });
  }

  // =========================
  // 2) è¨­å®š
  // =========================
  const CONF = {
    canvasW: 420,
    canvasH: 720,

    baseWidth: 220,
    blockHDefault: 34,    // fallbackæ™‚ã®æ¨™æº–é«˜ã•
    minWidth: 26,
    marginX: 16,

    speedBase: 2.6,
    speedPerLevel: 0.10,

    perfectPx: 3,         // åŸºæœ¬PERFECTå¹…
    camFollowFrom: 10,
    grid: true,

    // âœ… é€²æ—è¡¨ç¤ºã®å˜ä½ï¼ˆã“ã“ã§åˆ‡æ›¿ï¼‰
    // "FLOOR" = ä½•éšï¼ˆç©ã‚“ã æ®µæ•°ï¼‰
    // "METER" = ä½•mï¼ˆç©ã‚“ã é«˜ã•ã®åˆè¨ˆï¼‰
    PROGRESS_MODE: "FLOOR",

    // "METER" ã®æ›ç®—ï¼š1ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆæ¨™æº–é«˜ã•34pxï¼‰ã‚’ä½•mã«ã™ã‚‹ã‹
    METER_PER_STANDARD_BLOCK: 0.7,

    // è¡¨ç¤ºå°æ•°ï¼ˆMETERæ™‚ï¼‰
    METER_DECIMALS: 1,
  };

  // =========================
  // 3) ç¨®é¡ Ã— é«˜ã• Ã— ãƒ¬ã‚¢åº¦ï¼ˆå®Œå…¨ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
  // =========================
  const BLOCK_TABLE = [
    // ===== Common =====
    { key:"takoA", w:40, h:28, label:"è–„ç„¼ã" },
    { key:"takoB", w:45, h:34, label:"å®šç•ª"   },
    { key:"takoC", w:35, h:40, label:"å±±ç››ã‚Š" },

    // ===== Rare =====
    { key:"takoG", w:8,  h:34, label:"é‡‘ç„¼ã", perfectPlus: 2, bonus: 0 }, // PERFECTç”˜ã
    { key:"takoR", w:5,  h:40, label:"æ¿€è¾›",   speedMul: 1.18, bonus: 0 }, // é€Ÿã„

    // ===== Ultra Rare =====
    { key:"takoX", w:2,  h:46, label:"è™¹ä¼èª¬", insurance: true, bonus: 0 } // ä¿é™º
  ];

  // åŒã˜ã®é€£ç¶šå›é¿
  let lastKey = null;

  function pickBlockDef(){
    if (BLOCK_TABLE.length <= 1) return BLOCK_TABLE[0];

    let total = 0;
    for (const d of BLOCK_TABLE) total += d.w;

    for (let tries = 0; tries < 6; tries++){
      let r = Math.random() * total;
      for (const d of BLOCK_TABLE){
        r -= d.w;
        if (r <= 0){
          if (d.key === lastKey) break;
          lastKey = d.key;
          return d;
        }
      }
    }
    const fb = BLOCK_TABLE[Math.floor(Math.random() * BLOCK_TABLE.length)];
    lastKey = fb.key;
    return fb;
  }

  // =========================
  // 4) DOM
  // =========================
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const stateEl = document.getElementById("state");
  const toastEl = document.getElementById("toast");
  const stopBtn = document.getElementById("stopBtn");
  const restartBtn = document.getElementById("restartBtn");

  // ç”»é¢ã‚¿ãƒƒãƒ—ã§ã‚‚STOP
  cv.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    if (!S.playing) start();
    else drop();
  }, { passive:false });

  stopBtn.addEventListener("click", () => {
    if (!S.playing) start();
    else drop();
  });

  restartBtn.addEventListener("click", reset);

  // =========================
  // 5) ä¿å­˜ï¼ˆãƒ™ã‚¹ãƒˆï¼‰
  // =========================
  const BEST_KEY = `takoyakiTimingTower_best_${CONF.PROGRESS_MODE}`;

  function loadBest(){
    const v = Number(localStorage.getItem(BEST_KEY) || 0);
    return Number.isFinite(v) ? v : 0;
  }
  function saveBest(v){
    localStorage.setItem(BEST_KEY, String(v));
  }

  // =========================
  // 6) çŠ¶æ…‹
  // =========================
  const S = {
    playing: false,
    over: false,

    // âœ… é€²æ—ï¼ˆç‚¹æ•°ã§ã¯ãªãéš/ãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
    progress: 0,
    best: loadBest(),

    level: 0,
    cameraY: 0,
    dir: 1,

    blocks: [],
    curr: null
  };

  // =========================
  // 7) UI
  // =========================
  function showToast(text){
    toastEl.textContent = text;
    toastEl.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove("show"), 520);
  }

  function formatProgress(v){
    if (CONF.PROGRESS_MODE === "METER"){
      return `${v.toFixed(CONF.METER_DECIMALS)}m`;
    }
    return `${Math.floor(v)}F`;
  }

  function setHUD(){
    scoreEl.textContent = formatProgress(S.progress);
    bestEl.textContent  = formatProgress(S.best);
    stateEl.textContent = S.over ? "GAME OVER" : (S.playing ? "PLAYING" : "READY");
  }

  // =========================
  // 8) ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆ
  // =========================
  function makeBlock({
    x, width, y,
    h = CONF.blockHDefault,
    tileKey = null,
    label = "",
    bonus = 0,
    perfectPlus = 0,
    speedMul = 1,
    insurance = false
  }){
    return { x, width, y, h, tileKey, label, bonus, perfectPlus, speedMul, insurance };
  }

  function spawnBase(){
    const w = CONF.baseWidth;
    const x = (CONF.canvasW - w) / 2;
    const def = pickBlockDef();
    const y = CONF.canvasH - 90;

    const base = makeBlock({
      x, width: w, y,
      h: def.h,
      tileKey: def.key,
      label: def.label || "",
      bonus: def.bonus || 0,
      perfectPlus: def.perfectPlus || 0,
      speedMul: def.speedMul || 1,
      insurance: !!def.insurance
    });

    S.blocks = [base];
    S.level = 1;
  }

  function spawnCurrent(){
    const prev = S.blocks[S.blocks.length - 1];
    const def = pickBlockDef();

    const w = prev.width;
    const h = def.h;
    const y = prev.y - h;

    const startLeft = (S.level % 2 === 0);
    const x = startLeft ? CONF.marginX : (CONF.canvasW - CONF.marginX - w);
    S.dir = startLeft ? 1 : -1;

    S.curr = makeBlock({
      x, width: w, y,
      h,
      tileKey: def.key,
      label: def.label || "",
      bonus: def.bonus || 0,
      perfectPlus: def.perfectPlus || 0,
      speedMul: def.speedMul || 1,
      insurance: !!def.insurance
    });

    // å‡ºç¾æ¼”å‡ºï¼ˆè»½ãï¼‰
    if (S.curr.insurance) showToast("ğŸŒˆ è™¹ä¼èª¬ï¼šä¿é™ºä»˜ãï¼");
    else if ((S.curr.perfectPlus || 0) > 0) showToast("ğŸ¥‡ é‡‘ç„¼ãï¼šç”˜åˆ¤å®šï¼");
    else if ((S.curr.speedMul || 1) > 1) showToast("ğŸŒ¶ æ¿€è¾›ï¼šé«˜é€Ÿï¼");
  }

  // =========================
  // 9) é€²æ—ï¼ˆéš / ãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
  // =========================
  function computeProgressFromBlocks(){
    // blocks[0] ã¯åœŸå°ã€‚ç©ã‚“ã æ®µæ•° = blocks.length - 1
    const floors = Math.max(0, S.blocks.length - 1);

    if (CONF.PROGRESS_MODE === "FLOOR"){
      return floors;
    }

    // METERï¼šç©ã‚“ã é«˜ã•åˆè¨ˆã‚’æ›ç®—
    // ã€Œæ¨™æº–34px = 0.7mã€æ›ç®—ï¼ˆãƒ–ãƒ­ãƒƒã‚¯é«˜ã•ãŒé•ã†ã»ã©ä¼¸ã³ãŒå¤‰ã‚ã‚‹ï¼‰
    let sum = 0;
    for (let i = 1; i < S.blocks.length; i++){
      const b = S.blocks[i];
      sum += (b.h / 34) * CONF.METER_PER_STANDARD_BLOCK;
    }
    return sum;
  }

  // =========================
  // 10) ã‚²ãƒ¼ãƒ é€²è¡Œ
  // =========================
  function reset(){
    S.playing = false;
    S.over = false;

    S.progress = 0;

    S.cameraY = 0;
    S.dir = 1;

    spawnBase();
    spawnCurrent();

    S.progress = computeProgressFromBlocks();
    setHUD();
    draw();
  }

  function start(){
    if (S.over) reset();
    S.playing = true;
    setHUD();
  }

  function gameOver(){
    S.over = true;
    S.playing = false;
    setHUD();
    showToast("ç„¼ãå¤±æ•—â€¦ GAME OVER");
  }

  function levelSpeed(){
    const base = CONF.speedBase + S.level * CONF.speedPerLevel;
    const mul = (S.curr && S.curr.speedMul) ? S.curr.speedMul : 1;
    return base * mul;
  }

  // STOPã§ç¢ºå®šï¼ˆé‡ãªã‚Šè¨ˆç®—ï¼‰
  function drop(){
    if (!S.curr || S.over) return;

    const prev = S.blocks[S.blocks.length - 1];
    const curr = S.curr;

    const overlapLeft  = Math.max(prev.x, curr.x);
    const overlapRight = Math.min(prev.x + prev.width, curr.x + curr.width);
    const overlapW = overlapRight - overlapLeft;

    // å®Œå…¨ã«å¤–ã‚ŒãŸ
    if (overlapW <= 0){
      gameOver();
      return;
    }

    // âœ… PERFECTåˆ¤å®šï¼ˆé‡‘ç„¼ãã¯+2pxãªã©ï¼‰
    const diff = Math.abs(curr.x - prev.x);
    const perfectRange = CONF.perfectPx + (curr.perfectPlus || 0);
    const isPerfect = diff <= perfectRange;

    // âœ… è™¹ä¼èª¬ï¼š1å›ã ã‘å‰Šã‚Œãªã„ä¿é™ºï¼ˆæ¶ˆè²»ï¼‰
    // ã€Œé‡ãªã‚Šã¯ã‚ã‚‹ãŒå‰Šã‚Œã‚‹ã€å ´é¢ã§ã€1å›ã ã‘ width ã‚’ç¶­æŒ
    const willShrink = overlapW < curr.width;
    if (curr.insurance && willShrink){
      curr.x = overlapLeft;       // ä½ç½®ã ã‘åˆã‚ã›ã‚‹
      // curr.widthã¯ç¶­æŒï¼ˆå‰Šã‚Œãªã„ï¼‰
      curr.insurance = false;     // æ¶ˆè²»
      showToast("ğŸŒˆ è™¹ä¼èª¬ç™ºå‹•ï¼šã‚»ãƒ¼ãƒ•ï¼");
    } else if (isPerfect){
      // PERFECTãªã‚‰ä¸‹ã¨ãƒ”ãƒƒã‚¿ãƒªã«è£œæ­£ï¼†å¹…ç¶­æŒ
      curr.x = prev.x;
      curr.width = prev.width;
      showToast("PERFECT!!");
    } else {
      // é€šå¸¸ï¼šé‡ãªã‚Šåˆ†ã ã‘æ®‹ã™
      curr.x = overlapLeft;
      curr.width = overlapW;
    }

    // ç¢ºå®š
    S.blocks.push(curr);
    S.curr = null;

    // æœ€å°å¹…ãƒã‚§ãƒƒã‚¯
    if (curr.width < CONF.minWidth){
      gameOver();
      return;
    }

    // æ¬¡ã®æ®µã¸
    S.level++;

    // ã‚«ãƒ¡ãƒ©è¿½éš
    if (S.blocks.length > CONF.camFollowFrom){
      const top = S.blocks[S.blocks.length - 1];
      const targetY = (CONF.canvasH * 0.35) - top.y;
      S.cameraY = Math.max(S.cameraY, targetY);
    }

    // âœ… é€²æ—æ›´æ–°ï¼ˆéš / ãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
    S.progress = computeProgressFromBlocks();

    // ãƒ™ã‚¹ãƒˆæ›´æ–°
    if (S.progress > S.best){
      S.best = S.progress;
      saveBest(S.best);
    }

    spawnCurrent();
    setHUD();
  }

  // =========================
  // 11) æ›´æ–°ãƒ«ãƒ¼ãƒ—
  // =========================
  function update(){
    if (S.playing && !S.over && S.curr){
      const sp = levelSpeed();
      S.curr.x += sp * S.dir;

      const minX = CONF.marginX;
      const maxX = CONF.canvasW - CONF.marginX - S.curr.width;

      if (S.curr.x <= minX){
        S.curr.x = minX;
        S.dir = 1;
      } else if (S.curr.x >= maxX){
        S.curr.x = maxX;
        S.dir = -1;
      }
    }
  }

  // =========================
  // 12) æç”»ï¼ˆãƒ‰ãƒƒãƒˆçµµã‚¿ã‚¤ãƒ«ï¼‰
  // =========================
  function drawBG(){
    if (!CONF.grid) return;
    ctx.save();
    ctx.globalAlpha = 0.12;
    const step = 30;
    for (let y=0; y<CONF.canvasH; y+=step){
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(CONF.canvasW,y);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  }

  function roundedPath(x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function roundRect(x, y, w, h, r, fillStyle){
    ctx.save();
    ctx.fillStyle = fillStyle;
    ctx.beginPath();
    roundedPath(x, y, w, h, r);
    ctx.fill();
    ctx.restore();
  }

  function drawBlock(b){
    const y = b.y + S.cameraY;
    if (y > CONF.canvasH + 80 || y < -140) return;

    const x = Math.round(b.x);
    const w = Math.round(b.width);
    const h = Math.round(b.h);
    const r = 10;

    const tile = b.tileKey ? IMG[b.tileKey] : null;

    // ç”»åƒãŒãªã„å ´åˆã¯fallback
    if (!tile || !tile.naturalWidth){
      const grad = ctx.createLinearGradient(x, y, x, y+h);
      grad.addColorStop(0, "#ffd34d");
      grad.addColorStop(1, "#f08b2f");
      roundRect(x, y, w, h, r, grad);
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,.45)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      roundedPath(x, y, w, h, r);
      ctx.stroke();
      ctx.restore();
      return;
    }

    // ã‚¿ã‚¤ãƒ«æ•·ãè©°ã‚ï¼ˆé«˜ã•ã«åˆã‚ã›ã¦ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
    const scale = h / tile.naturalHeight;
    const tileW = Math.max(1, Math.round(tile.naturalWidth * scale));

    // è§’ä¸¸ã‚¯ãƒªãƒƒãƒ—
    ctx.save();
    ctx.beginPath();
    roundedPath(x, y, w, h, r);
    ctx.clip();

    for (let xx = x; xx < x + w; xx += tileW){
      ctx.drawImage(tile, xx, y, tileW, h);
    }

    ctx.restore();

    // æ ç·š
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,.45)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    roundedPath(x, y, w, h, r);
    ctx.stroke();
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,CONF.canvasW, CONF.canvasH);

    // âœ… ãƒ‰ãƒƒãƒˆçµµã¼ã‚„ã‘é˜²æ­¢
    ctx.imageSmoothingEnabled = false;

    drawBG();

    for (const b of S.blocks) drawBlock(b);
    if (S.curr) drawBlock(S.curr);

    // å·¦ä¸Šè¡¨ç¤ºï¼ˆå˜ä½è¾¼ã¿ï¼‰
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#fff";
    ctx.font = "700 12px system-ui, sans-serif";
    const unit = (CONF.PROGRESS_MODE === "METER") ? "m" : "F";
    ctx.fillText(`TOP: ${formatProgress(S.progress)}  (${unit})`, 14, 24);
    ctx.restore();

    if (S.over){
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, CONF.canvasW, CONF.canvasH);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.font = "900 34px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", CONF.canvasW/2, CONF.canvasH*0.44);
      ctx.font = "700 16px system-ui, sans-serif";
      ctx.fillText("RESTART ã§å†æŒ‘æˆ¦", CONF.canvasW/2, CONF.canvasH*0.50);
      ctx.restore();
    }
  }

  // =========================
  // 13) ãƒ«ãƒ¼ãƒ—
  // =========================
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // =========================
  // 14) åˆæœŸåŒ–ï¼ˆç”»åƒãƒ­ãƒ¼ãƒ‰â†’é–‹å§‹ï¼‰
  // =========================
  loadImages().then(() => {
    setHUD();
    reset();
    loop();
  });
})();
</script>


</body>
</html>

