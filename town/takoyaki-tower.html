<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
<title>ãŸã“ç„¼ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼</title>
<style>
  :root{
    --w: 420px;
    --h: 720px;
  }
  body{
    margin:0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
    background:#0f1115;
    color:#fff;
    display:flex;
    min-height:100svh;
    align-items:center;
    justify-content:center;
  }
  .wrap{
    width:min(var(--w), 100vw);
    padding:10px 10px 14px;
    box-sizing:border-box;
  }
  .hud{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin:6px 2px 10px;
    font-size:14px;
    opacity:.95;
  }
  .hud b{ font-size:16px; }
  .panel{
    background:#141824;
    border:1px solid rgba(255,255,255,.08);
    border-radius:14px;
    overflow:hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  canvas{
    width:100%;
    height:auto;
    display:block;
    background: radial-gradient(120% 80% at 50% 15%, rgba(255,255,255,.06), rgba(0,0,0,0) 50%),
                linear-gradient(#0f1320, #0b0d13);
    touch-action:manipulation;
  }
  .controls{
    display:flex;
    gap:10px;
    padding:10px;
    background: rgba(0,0,0,.18);
    border-top:1px solid rgba(255,255,255,.08);
  }
  button{
    flex:1;
    appearance:none;
    border:0;
    border-radius:12px;
    padding:14px 12px;
    font-weight:700;
    font-size:16px;
    color:#111;
    background:#ffd34d;
    cursor:pointer;
  }
  button.secondary{
    background:#2a3147;
    color:#fff;
    font-weight:600;
  }
  .toast{
    position:absolute;
    left:50%;
    top:18%;
    transform:translateX(-50%);
    background: rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.18);
    padding:10px 14px;
    border-radius:999px;
    font-weight:800;
    letter-spacing:.02em;
    opacity:0;
    transition: opacity .15s ease, transform .15s ease;
    pointer-events:none;
    white-space:nowrap;
  }
  .toast.show{
    opacity:1;
    transform:translateX(-50%) translateY(-2px);
  }
  .hint{
    font-size:12px;
    opacity:.75;
    margin-top:10px;
    line-height:1.5;
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div>Score: <b id="score">0</b></div>
    <div>Best: <b id="best">0</b></div>
    <div id="state">READY</div>
  </div>

  <div class="panel" style="position:relative;">
    <div id="toast" class="toast">PERFECT!!</div>
    <canvas id="cv" width="420" height="720" aria-label="ãŸã“ç„¼ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼"></canvas>
    <div class="controls">
      <button id="stopBtn">STOPï¼ˆã‚¿ãƒƒãƒ—ï¼‰</button>
      <button id="restartBtn" class="secondary">RESTART</button>
    </div>
  </div>

  <div class="hint">
    ãƒ»æ“ä½œã¯ã€ŒSTOPã€ã ã‘ã€‚<br/>
    ãƒ»ä¸‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨é‡ãªã£ãŸåˆ†ã ã‘æ®‹ã‚Šã¾ã™ã€‚<br/>
    ãƒ»PERFECTï¼ˆã»ã¼åŒã˜ä½ç½®ï¼‰ã ã¨å‰Šã‚Œã¾ã›ã‚“ã€‚<br/>
  </div>
</div>
<script>
(() => {
  /* =========================================================
     âœ… ãŸã“ç„¼ãã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚¿ãƒ¯ãƒ¼ï¼ˆå®Œå…¨ç‰ˆï¼šã‚¹ã‚³ã‚¢å®Ÿè£…ï¼‰
     - åŸºæº–ç‚¹ï¼šéšæ•°ã«å¿œã˜ã¦å¢—ãˆã‚‹
     - æ—©æŠ¼ã—ãƒœãƒ¼ãƒŠã‚¹ï¼šå‡ºç¾ã—ã¦æ—©ãè½ã¨ã™ã»ã©åŠ ç‚¹
     - PERFECTï¼šå€ç‡ï¼†ã‚³ãƒ³ãƒœåŠ ç®—ï¼ˆÃ—1.2â†’Ã—1.3â†’â€¦ï¼‰
     - çµæœç”»é¢ï¼šæ•—å› /æœ€å¾Œã®ç„¼ã/å±¥æ­´ã¯è¡¨ç¤ºã—ãªã„
     - èƒŒæ™¯ï¼šæ˜¼â†’å¤•â†’å¤œï¼ˆ0-20-60ï¼‰
     - è§’ï¼šå››éš…è§’ä¸¸ï¼ˆä¸‹ã‚‚ä¸¸ã„ï¼‰
  ========================================================= */

  // =========================
  // ç”»åƒURLï¼ˆã“ã“ã ã‘å·®ã—æ›¿ãˆï¼‰
  // =========================
  const SPR = {
    takoA: "https://ul.h3z.jp/OPpiBayk.png", // ç´ ç„¼ã
    takoB: "https://ul.h3z.jp/8lVPkSPJ.png", // ã‚¤ã‚«ã•ã¾ç„¼ã
    takoC: "https://ul.h3z.jp/rbG1ovxG.png", // ç”Ÿç„¼ã‘
    takoG: "https://ul.h3z.jp/XPTM8m5U.png", // é‡‘ç„¼ã
    takoR: "https://ul.h3z.jp/dXRcAx01.png", // æ¿€è¾›
    takoX: "https://ul.h3z.jp/Uia1oOpk.png", // è™¹ä¼èª¬
  };

  const IMG = {};
  function loadImages(){
    const entries = Object.entries(SPR);
    let loaded = 0;
    return new Promise((resolve) => {
      if (!entries.length){ resolve(); return; }
      for (const [key, src] of entries){
        const im = new Image();
        im.onload = () => { IMG[key] = im; loaded++; if (loaded === entries.length) resolve(); };
        im.onerror = () => { console.warn("Image load failed:", key, src); loaded++; if (loaded === entries.length) resolve(); };
        im.src = src;
      }
    });
  }

  // =========================
  // è¨­å®šï¼ˆãƒãƒ©ãƒ³ã‚¹èª¿æ•´è¾¼ã¿ï¼‰
  // =========================
  const CONF = {
    canvasW: 420,
    canvasH: 720,

    baseWidth: 230,
    blockHDefault: 34,
    minWidth: 34,
    marginX: 16,

    speedBase: 2.25,
    speedPerLevel: 0.085,
    perfectPx: 4,

    grid: true,

    PROGRESS_MODE: "FLOOR",
    CAMERA_ANCHOR_Y: 0.28,
    CAMERA_SMOOTH: 0.16,
    CAMERA_MIN: 0,

    KEEP_BLOCKS_DRAW: 140,

    BLOCK_DRAW_MODE: "COVER",

    // âœ… ä¸‹5æ®µã ã‘è¦‹ãŸç›®é«˜ã•ãƒ–ãƒ¼ã‚¹ãƒˆï¼ˆè¼ªåˆ‡ã‚Šå¯¾ç­–ï¼‰
    BASE_BOOST: [1.65, 1.55, 1.45, 1.35, 1.25],

    // âœ… ã‚¹ã‚³ã‚¢è¨­è¨ˆ
    SCORE_BASE0: 60,        // 1æ®µç›®ã®åŸºæº–ç‚¹ã®åœŸå°
    SCORE_PER_FLOOR: 10,    // éšæ•°ã”ã¨ã®åŸºæº–ç‚¹å¢—åˆ†
    SPEED_BONUS_FAST_MS: 450,
    SPEED_BONUS_MID_MS: 850,
    SPEED_BONUS_FAST: 40,
    SPEED_BONUS_MID: 20,

    PERFECT_MUL: 1.30,      // PERFECTã®åŸºæœ¬å€ç‡
    NEAR_MUL: 1.12,         // ã»ã¼æˆåŠŸï¼ˆè¿‘ã„ï¼‰ã®å€ç‡
    COMBO_MUL_ADD: 0.05,    // PERFECTé€£ç¶šã§å€ç‡ãŒè‚²ã¤
    MUL_CAP: 2.00,          // å€ç‡ä¸Šé™ï¼ˆæš´èµ°é˜²æ­¢ï¼‰
  };

  // =========================
  // ç¨®é¡ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆå‡ºç¾ç‡p / é«˜ã•hï¼‰
  // =========================
  const BLOCK_TABLE = [
    { key:"takoA", p: 44, h: 26, label:"ç´ ç„¼ãï¼ˆè–„ï¼‰", speedMul: 1.05 },
    { key:"takoB", p: 40, h: 34, label:"ã‚¤ã‚«ã•ã¾ï¼ˆæ¨™æº–ï¼‰", speedMul: 1.12 },
    { key:"takoC", p: 30, h: 46, label:"ç”Ÿç„¼ã‘ï¼ˆåšï¼‰", speedMul: 0.90 },

    { key:"takoG", p: 10, h: 30, label:"é‡‘ç„¼ã", perfectPlus: 3, speedMul: 1.20 },
    { key:"takoR", p:  7, h: 38, label:"æ¿€è¾›",  speedMul: 1.45 },
    { key:"takoX", p:  4, h: 42, label:"è™¹ä¼èª¬", insurance: true, speedMul: 1.10 },
  ];

  let lastKey = null;
  function pickBlockDef(){
    let total = 0;
    for (const d of BLOCK_TABLE) total += (d.p ?? 1);

    for (let tries=0; tries<8; tries++){
      let r = Math.random() * total;
      for (const d of BLOCK_TABLE){
        r -= (d.p ?? 1);
        if (r <= 0){
          if (d.key === lastKey) break;
          lastKey = d.key;
          return d;
        }
      }
    }
    const fb = BLOCK_TABLE[Math.floor(Math.random() * BLOCK_TABLE.length)];
    lastKey = fb.key;
    return fb;
  }

  // =========================
  // DOM
  // =========================
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const scoreEl = document.getElementById("score"); // â† ã“ã“ã¯ã€Œç‚¹æ•°ã€ã‚’è¡¨ç¤º
  const bestEl  = document.getElementById("best");  // â† BESTç‚¹æ•°
  const stateEl = document.getElementById("state");
  const toastEl = document.getElementById("toast");
  const stopBtn = document.getElementById("stopBtn");
  const restartBtn = document.getElementById("restartBtn");

  // =========================
  // ä¿å­˜
  // =========================
  const BEST_POINT_KEY = "takoyakiTimingTower_best_points";
  function loadBestPoints(){
    const v = Number(localStorage.getItem(BEST_POINT_KEY) || 0);
    return Number.isFinite(v) ? v : 0;
  }
  function saveBestPoints(v){
    localStorage.setItem(BEST_POINT_KEY, String(v));
  }

  // =========================
  // çŠ¶æ…‹
  // =========================
  const S = {
    playing: false,
    over: false,

    // é€²è¡Œï¼ˆæ®µæ•°ï¼‰
    floors: 0,

    // ç‚¹æ•°
    points: 0,
    bestPoints: loadBestPoints(),

    // å€ç‡é–¢é€£
    mul: 1.0,
    comboPerfect: 0,

    level: 0,
    cameraY: 0,
    dir: 1,

    blocks: [],
    curr: null,
    allBlocks: [],

    // çµæœ
    lastTitle: "",
    lastSubtitle: "",
    lastRunAt: "",
    lastRunFloors: 0,
    lastRunPoints: 0,
  };

  // =========================
  // ãƒˆãƒ¼ã‚¹ãƒˆ
  // =========================
  function showToast(text){
    toastEl.textContent = text;
    toastEl.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove("show"), 520);
  }

  // =========================
  // èƒŒæ™¯ï¼šæ˜¼â†’å¤•â†’å¤œ
  // =========================
  const SKY_COLORS = {
    day:    { top:"#a9cfe6", bottom:"#eaf5fb" },
    sunset: { top:"#f0b38c", bottom:"#6b4e71" },
    night:  { top:"#0b132b", bottom:"#1c2541" },
  };
  function getTimePhase(floors){
    if (floors < 20) return "day";
    if (floors < 60) return "sunset";
    return "night";
  }

  // =========================
  // UI
  // =========================
  function setHUD(){
    scoreEl.textContent = String(S.points);
    bestEl.textContent  = String(S.bestPoints);
    stateEl.textContent = S.over ? `GAME OVER / ${S.floors}F` : (S.playing ? `${S.floors}F Ã—${S.mul.toFixed(2)}` : "READY");
  }

  // =========================
  // ç§°å·ï¼ˆãŸã“ã´å£èª¿ãƒ»ã‚®ãƒ£ã‚°ç‰ˆï¼‰
  // =========================
  function getTakoyakiTitle(floors){
    const p = Math.floor(floors);
    const table = [
      { min: 0,   title:"ã€˜æœªæŠ•å…¥ã€™",                 sub:"ã¾ã é‰„æ¿ã«ã€ã“ã‚“ã«ã¡ã¯ã—ã¦ãªã„ãŸã“ã€‚" },
      { min: 1,   title:"ã€˜ã¯ã˜ã‚ã¦ç½®ã„ãŸãŸã“ã€™",   sub:"ä»Šã®éŸ³ã€ã¡ã‚‡ã£ã¨è‰¯ã‹ã£ãŸãŸã“ã€‚" },
      { min: 5,   title:"ã€˜è¿”ã›ãŸæ°—ãŒã™ã‚‹ãŸã“ã€™",   sub:"ãŸã¶ã‚“åˆã£ã¦ãŸã€‚ãŸã¶ã‚“ãŸã“ã€‚" },
      { min: 10,  title:"ã€˜æ¹¯æ°—ã¿ã¦ãŸã ã‘ã®ãŸã“ã€™", sub:"è¦‹ã¦ãŸã‚‰ã€ç©ã‚ã¦ãŸãŸã“ã€‚" },
      { min: 15,  title:"ã€˜ã¡ã„ã•ããªã£ã¦ã‚‚æ°—ã«ã—ãªã„ãŸã“ã€™", sub:"ä¸¸ã¯ã€å¿ƒã ã¨æ€ã†ãŸã“ã€‚" },
      { min: 20,  title:"ã€˜é‰„æ¿ã¨ä»²è‰¯ããªã£ãŸãŸã“ã€™", sub:"ç„¦ã’ã‚‚ã€å‹ã ã¡ãŸã“ã€‚" },
      { min: 30,  title:"ã€˜ã‚¿ã‚³æ°‘ã«é¡”è¦šãˆã‚‰ã‚ŒãŸãŸã“ã€™", sub:"ã‚ã€ã¾ãŸæ¥ãŸãŸã“ã€ã£ã¦è¨€ã‚ã‚ŒãŸãŸã“ã€‚" },
      { min: 40,  title:"ã€˜ç¥­å£‡ãŒãƒãƒ©è¦‹ã—ã¦ããŸãŸã“ã€™", sub:"ä»Šã€è¦‹ã‚‰ã‚ŒãŸæ°—ãŒã—ãŸãŸã“ã€‚" },
      { min: 50,  title:"ã€˜PERFECTã£ã½ã„ãŸã“ã€™",     sub:"ã‚ºãƒ¬ã¦ãªã„â€¦æ°—ãŒã™ã‚‹ãŸã“ã€‚" },
      { min: 70,  title:"ã€˜è½ã¡ãªã‹ã£ãŸãŸã“ã€™",       sub:"ç†ç”±ã¯åˆ†ã‹ã‚‰ãªã„ãŸã“ã€‚" },
      { min: 100, title:"ã€˜ç„¼ã‹ã‚ŒãŸä¼èª¬ã€™",           sub:"ã‚«ãƒ¼ãƒ‰ã«ãªã‚‹ã£ã¦è¨€ã‚ã‚ŒãŸãŸã“ã€‚" },
      { min: 130, title:"ã€˜è¿”ã—ã™ããŸãŸã“ã€™",         sub:"æ‰‹ãŒå…ˆã«å‹•ã„ã¦ãŸã“ã€‚" },
      { min: 160, title:"ã€˜é‰„æ¿ã®å‘ã“ã†è¦‹ãˆãŸãŸã“ã€™", sub:"æˆ»ã‚Šæ–¹ã€å¿˜ã‚ŒãŸãŸã“ã€‚" },
      { min: 200, title:"ã€˜ç¥è©±ç´šãƒ»ä¸¸ã‚’ç®¡ç†ã™ã‚‹ãŸã“ã€™", sub:"ä¸¸ãŒã€è¨±å¯ã‚’å–ã‚Šã«æ¥ãŸãŸã“ã€‚" },
    ];
    let pick = table[0];
    for (const row of table){
      if (p >= row.min) pick = row;
    }
    return pick;
  }

  // =========================
  // ãƒ–ãƒ­ãƒƒã‚¯æ§‹é€ 
  // =========================
  function makeBlock({ x, width, y, h, tileKey, label="", perfectPlus=0, speedMul=1, insurance=false, spawnedAt=0 }){
    return { x, width, y, h, tileKey, label, perfectPlus, speedMul, insurance, spawnedAt };
  }

  function pushConfirmedBlock(b){
    S.blocks.push(b);
    S.allBlocks.push({ x: b.x, y: b.y, width: b.width, h: b.h, tileKey: b.tileKey });

    if (CONF.KEEP_BLOCKS_DRAW > 0 && S.blocks.length > CONF.KEEP_BLOCKS_DRAW){
      S.blocks = S.blocks.slice(S.blocks.length - CONF.KEEP_BLOCKS_DRAW);
    }
  }

  // =========================
  // åˆæœŸãƒ–ãƒ­ãƒƒã‚¯
  // =========================
  function spawnBase(){
    const def = pickBlockDef();
    const w = CONF.baseWidth;
    const x = (CONF.canvasW - w) / 2;
    const y = CONF.canvasH - 90;

    const base = makeBlock({
      x, width: w, y,
      h: def.h ?? CONF.blockHDefault,
      tileKey: def.key,
      label: def.label || "",
      perfectPlus: def.perfectPlus || 0,
      speedMul: def.speedMul || 1,
      insurance: !!def.insurance
    });

    S.blocks = [];
    S.allBlocks = [];
    pushConfirmedBlock(base);
    S.level = 1;
  }

  function spawnCurrent(){
    const prev = S.blocks[S.blocks.length - 1];
    const def = pickBlockDef();

    const w = prev.width;
    const h = def.h ?? CONF.blockHDefault;
    const y = prev.y - h;

    const startLeft = (S.level % 2 === 0);
    const x = startLeft ? CONF.marginX : (CONF.canvasW - CONF.marginX - w);
    S.dir = startLeft ? 1 : -1;

    S.curr = makeBlock({
      x, width: w, y, h,
      tileKey: def.key,
      label: def.label || "",
      perfectPlus: def.perfectPlus || 0,
      speedMul: def.speedMul || 1,
      insurance: !!def.insurance,
      spawnedAt: performance.now(), // âœ… æ—©æŠ¼ã—è¨ˆæ¸¬
    });

    // ä¸€è¨€æ¼”å‡ºï¼ˆä»»æ„ï¼‰
    if (S.curr.insurance) showToast("ğŸŒˆ è™¹ä¼èª¬ï¼ˆ1å›ã‚»ãƒ¼ãƒ•ï¼‰");
    else if ((S.curr.perfectPlus||0) > 0) showToast("ğŸ¥‡ é‡‘ç„¼ãï¼ˆç”˜åˆ¤å®šï¼‰");
    else if ((S.curr.speedMul||1) > 1.3) showToast("ğŸŒ¶ æ¿€è¾›ï¼ˆé«˜é€Ÿï¼‰");
  }

  // =========================
  // ã‚«ãƒ¡ãƒ©è¿½éš
  // =========================
  function getTopMostY(){
    let topY = Infinity;
    for (const b of S.blocks){
      if (Number.isFinite(b.y)) topY = Math.min(topY, b.y);
    }
    if (S.curr && Number.isFinite(S.curr.y)) topY = Math.min(topY, S.curr.y);
    if (!Number.isFinite(topY)) topY = 0;
    return topY;
  }

  function updateCamera(){
    const topY = getTopMostY();
    const anchorY = CONF.canvasH * CONF.CAMERA_ANCHOR_Y;
    const target = Math.max(CONF.CAMERA_MIN, anchorY - topY);
    S.cameraY += (target - S.cameraY) * CONF.CAMERA_SMOOTH;
  }

  // =========================
  // ã‚¹ã‚³ã‚¢è¨ˆç®—
  // =========================
  function getBaseScore(floor){
    return CONF.SCORE_BASE0 + floor * CONF.SCORE_PER_FLOOR;
  }

  function getSpeedBonus(ms){
    if (ms <= CONF.SPEED_BONUS_FAST_MS) return CONF.SPEED_BONUS_FAST;
    if (ms <= CONF.SPEED_BONUS_MID_MS)  return CONF.SPEED_BONUS_MID;
    return 0;
  }

  function clampMul(m){
    return Math.min(CONF.MUL_CAP, Math.max(1.0, m));
  }

  // =========================
  // çµæœã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆæ•—å› /å±¥æ­´ãªã—ï¼‰
  // =========================
  let resultOverlay = null;

  function ensureOverlay(){
    if (resultOverlay) return resultOverlay;

    const wrap = cv.closest(".panel") || document.body;

    const box = document.createElement("div");
    box.id = "takoyakiResultOverlay";
    box.style.position = "absolute";
    box.style.left = "0";
    box.style.top = "0";
    box.style.width = "100%";
    box.style.height = "100%";
    box.style.display = "none";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.zIndex = "9999";
    box.style.pointerEvents = "auto";

    const bg = document.createElement("div");
    bg.style.position = "absolute";
    bg.style.inset = "0";
    bg.style.background = "rgba(0,0,0,.72)";
    bg.style.backdropFilter = "blur(2px)";
    bg.style.webkitBackdropFilter = "blur(2px)";
    box.appendChild(bg);

    const card = document.createElement("div");
    card.style.position = "relative";
    card.style.width = "min(92%, 440px)";
    card.style.borderRadius = "18px";
    card.style.border = "1px solid rgba(255,255,255,.18)";
    card.style.background = "linear-gradient(180deg, rgba(24,28,40,.95), rgba(12,14,20,.95))";
    card.style.boxShadow = "0 20px 60px rgba(0,0,0,.55)";
    card.style.padding = "14px 14px 16px";
    card.style.boxSizing = "border-box";
    card.style.transform = "translateY(6px) scale(.98)";
    card.style.opacity = "0";
    card.style.transition = "transform .18s ease, opacity .18s ease";
    box.appendChild(card);

    // ãƒŸãƒ‹ã‚¿ãƒ¯ãƒ¼æ 
    const miniWrap = document.createElement("div");
    miniWrap.style.borderRadius = "16px";
    miniWrap.style.border = "1px solid rgba(255,255,255,.14)";
    miniWrap.style.background = "rgba(255,255,255,.05)";
    miniWrap.style.padding = "10px";
    miniWrap.style.marginBottom = "12px";
    card.appendChild(miniWrap);

    const miniTitle = document.createElement("div");
    miniTitle.style.fontWeight = "900";
    miniTitle.style.fontSize = "12px";
    miniTitle.style.opacity = ".8";
    miniTitle.style.marginBottom = "6px";
    miniTitle.textContent = "ã‚ãªãŸã®ã‚¿ãƒ¯ãƒ¼ï¼ˆç¸®å°å†ç¾ï¼‰";
    miniWrap.appendChild(miniTitle);

    const miniCanvas = document.createElement("canvas");
    miniCanvas.id = "resMiniCanvas";
    miniCanvas.width = 360;
    miniCanvas.height = 180;
    miniCanvas.style.width = "100%";
    miniCanvas.style.height = "auto";
    miniCanvas.style.display = "block";
    miniCanvas.style.imageRendering = "pixelated";
    miniCanvas.style.borderRadius = "12px";
    miniWrap.appendChild(miniCanvas);

    // ç§°å·
    const h1 = document.createElement("div");
    h1.id = "resTitle";
    h1.style.fontWeight = "900";
    h1.style.fontSize = "18px";
    h1.style.letterSpacing = ".02em";
    h1.style.marginBottom = "6px";
    card.appendChild(h1);

    const sub = document.createElement("div");
    sub.id = "resSub";
    sub.style.opacity = ".85";
    sub.style.fontSize = "13px";
    sub.style.lineHeight = "1.35";
    sub.style.marginBottom = "8px";
    card.appendChild(sub);

    const dt = document.createElement("div");
    dt.id = "resDate";
    dt.style.opacity = ".75";
    dt.style.fontSize = "12px";
    dt.style.margin = "0 0 10px";
    card.appendChild(dt);

    // åˆ°é”ï¼†BESTï¼ˆæ®µæ•°ï¼†ç‚¹æ•°ï¼‰
    const stats = document.createElement("div");
    stats.style.display = "grid";
    stats.style.gridTemplateColumns = "1fr 1fr";
    stats.style.gap = "10px";
    stats.style.marginBottom = "12px";
    card.appendChild(stats);

    const statA = document.createElement("div");
    statA.style.padding = "10px";
    statA.style.borderRadius = "14px";
    statA.style.border = "1px solid rgba(255,255,255,.12)";
    statA.style.background = "rgba(255,255,255,.06)";
    statA.innerHTML = `<div style="opacity:.75;font-size:12px;">åˆ°é”</div><div id="resReach" style="font-weight:900;font-size:20px;margin-top:2px;"></div><div id="resPts" style="opacity:.85;font-size:12px;margin-top:4px;"></div>`;
    stats.appendChild(statA);

    const statB = document.createElement("div");
    statB.style.padding = "10px";
    statB.style.borderRadius = "14px";
    statB.style.border = "1px solid rgba(255,255,255,.12)";
    statB.style.background = "rgba(255,255,255,.06)";
    statB.innerHTML = `<div style="opacity:.75;font-size:12px;">BEST</div><div id="resBestPts" style="font-weight:900;font-size:20px;margin-top:2px;"></div>`;
    stats.appendChild(statB);

    // ãƒœã‚¿ãƒ³
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "10px";
    card.appendChild(row);

    const againBtn = document.createElement("button");
    againBtn.type = "button";
    againBtn.textContent = "ã‚‚ã†ä¸€å›";
    againBtn.style.flex = "1";
    againBtn.style.border = "0";
    againBtn.style.borderRadius = "14px";
    againBtn.style.padding = "14px 12px";
    againBtn.style.fontWeight = "900";
    againBtn.style.background = "#ffd34d";
    againBtn.style.color = "#111";
    againBtn.style.cursor = "pointer";
    row.appendChild(againBtn);

    againBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      hideResultOverlay();
      reset();
      start();
    });

    // èƒŒæ™¯/ã‚«ãƒ¼ãƒ‰ã¯åå¿œã•ã›ãªã„ï¼ˆãƒœã‚¿ãƒ³ã ã‘ï¼‰
    bg.addEventListener("click", (e) => e.stopPropagation());
    card.addEventListener("click", (e) => e.stopPropagation());

    const st = getComputedStyle(wrap);
    if (st.position === "static") wrap.style.position = "relative";
    wrap.appendChild(box);

    resultOverlay = { box, card, miniCanvas };
    return resultOverlay;
  }

  function showResultOverlay(){
    const o = ensureOverlay();

    document.getElementById("resTitle").textContent = S.lastTitle || "ã€˜ç„¼ãçµæœã€™";
    document.getElementById("resSub").textContent   = S.lastSubtitle || "";
    document.getElementById("resDate").textContent  = S.lastRunAt ? `è¨˜éŒ²ï¼š${S.lastRunAt}` : "";

    document.getElementById("resReach").textContent = `${S.lastRunFloors}F`;
    document.getElementById("resPts").textContent   = `ç‚¹æ•°ï¼š${S.lastRunPoints}`;
    document.getElementById("resBestPts").textContent = String(S.bestPoints);

    renderTowerMini(o.miniCanvas, S.allBlocks);

    o.box.style.display = "flex";
    requestAnimationFrame(() => {
      o.card.style.opacity = "1";
      o.card.style.transform = "translateY(0) scale(1)";
    });
  }

  function hideResultOverlay(){
    if (!resultOverlay) return;
    const { box, card } = resultOverlay;
    card.style.opacity = "0";
    card.style.transform = "translateY(6px) scale(.98)";
    setTimeout(() => { box.style.display = "none"; }, 180);
  }

  function setResultDatetime(){
    S.lastRunAt = new Date().toLocaleString("ja-JP", {
      timeZone: "Asia/Tokyo",
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit"
    });
  }

  // =========================
  // ãƒŸãƒ‹ã‚¿ãƒ¯ãƒ¼ï¼ˆç¸®å°å†ç¾ï¼‰
  // =========================
  function drawImageCover(g, img, x, y, w, h){
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    if (!iw || !ih){ g.drawImage(img, x, y, w, h); return; }
    const s = Math.max(w / iw, h / ih);
    const dw = iw * s;
    const dh = ih * s;
    const dx = x + (w - dw) / 2;
    const dy = y + (h - dh) / 2;
    g.drawImage(img, dx, dy, dw, dh);
  }

  function renderTowerMini(canvas, blocks){
    const mctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    mctx.clearRect(0,0,W,H);
    mctx.imageSmoothingEnabled = false;

    // èƒŒæ™¯ï¼ˆæš—ãï¼‰
    mctx.save();
    mctx.globalAlpha = 0.20;
    mctx.fillStyle = "#000";
    mctx.fillRect(0,0,W,H);
    mctx.restore();

    if (!blocks || blocks.length === 0) return;

    // boundsï¼ˆä¸–ç•Œåº§æ¨™ï¼‰
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const b of blocks){
      minX = Math.min(minX, b.x);
      maxX = Math.max(maxX, b.x + b.width);
      minY = Math.min(minY, b.y);
      maxY = Math.max(maxY, b.y + b.h);
    }

    const pad = 10;
    const bw = Math.max(1, maxX - minX);
    const bh = Math.max(1, maxY - minY);
    const s = Math.min((W - pad*2) / bw, (H - pad*2) / bh);

    // å·¦å³ä¸­å¤® / ä¸‹æƒãˆ
    const ox = pad + (W - pad*2 - bw*s)/2 - minX*s;
    const oy = pad + (H - pad*2 - bh*s) - minY*s;

    const sorted = [...blocks].sort((a,b) => (a.y - b.y));
    for (const b of sorted){
      const x = Math.round(ox + b.x*s);
      const y = Math.round(oy + b.y*s);
      const w = Math.max(1, Math.round(b.width*s));
      const h = Math.max(1, Math.round(b.h*s));

      const tile = b.tileKey ? IMG[b.tileKey] : null;
      const r = Math.max(3, Math.round(Math.min(w, h) * 0.22));

      mctx.save();
      mctx.beginPath();
      roundedPathOn(mctx, x, y, w, h, r);
      mctx.clip();
      if (tile && tile.naturalWidth) drawImageCover(mctx, tile, x, y, w, h);
      else {
        mctx.fillStyle = "rgba(255,210,80,.9)";
        mctx.fillRect(x, y, w, h);
      }
      mctx.restore();
    }
  }

  function roundedPathOn(g, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    g.moveTo(x+rr, y);
    g.arcTo(x+w, y, x+w, y+h, rr);
    g.arcTo(x+w, y+h, x, y+h, rr);
    g.arcTo(x, y+h, x, y, rr);
    g.arcTo(x, y, x+w, y, rr);
    g.closePath();
  }

  // =========================
  // æç”»ï¼ˆãƒ¡ã‚¤ãƒ³ï¼‰
  // =========================
  function drawBG(){
    const phase = getTimePhase(S.floors);
    const sky = SKY_COLORS[phase];

    const grad = ctx.createLinearGradient(0,0,0,CONF.canvasH);
    grad.addColorStop(0, sky.top);
    grad.addColorStop(1, sky.bottom);
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,CONF.canvasW, CONF.canvasH);

    if (!CONF.grid) return;
    ctx.save();
    ctx.globalAlpha = 0.08;
    const step = 30;
    for (let y=0; y<CONF.canvasH; y+=step){
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(CONF.canvasW,y);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  }

  function roundedPath(x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawBlock(b, index){
    const y = b.y + S.cameraY;
    if (y > CONF.canvasH + 120 || y < -240) return;

    const x = Math.round(b.x);
    const w = Math.round(b.width);

    const boost = CONF.BASE_BOOST[index] ?? 1.0;
    const h = Math.round(b.h * boost);

    const tile = b.tileKey ? IMG[b.tileKey] : null;
    const rAll = Math.round(Math.min(w, h) * 0.40); // â† ã‚‚ã£ã¨ä¸¸ã„

    ctx.save();
    ctx.beginPath();
    roundedPath(x, y, w, h, rAll);
    ctx.clip();

    if (!tile || !tile.naturalWidth){
      const grad = ctx.createLinearGradient(x, y, x, y+h);
      grad.addColorStop(0, "#ffd34d");
      grad.addColorStop(1, "#f08b2f");
      ctx.fillStyle = grad;
      ctx.fillRect(x, y, w, h);
    } else if (CONF.BLOCK_DRAW_MODE === "COVER"){
      drawImageCover(ctx, tile, x, y, w, h);
    } else if (CONF.BLOCK_DRAW_MODE === "STRETCH"){
      ctx.drawImage(tile, x, y, w, h);
    } else {
      const scale = h / tile.naturalHeight;
      const tileW = Math.max(1, Math.round(tile.naturalWidth * scale));
      for (let xx = x; xx < x + w; xx += tileW){
        ctx.drawImage(tile, xx, y, tileW, h);
      }
    }

    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,CONF.canvasW, CONF.canvasH);
    ctx.imageSmoothingEnabled = false;

    drawBG();

    for (let i=0; i<S.blocks.length; i++){
      drawBlock(S.blocks[i], i);
    }
    if (S.curr) drawBlock(S.curr, S.blocks.length);

    // å·¦ä¸Šï¼ˆç‚¹æ•°/å€ç‡ï¼‰
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#fff";
    ctx.font = "700 12px system-ui, sans-serif";
    ctx.fillText(`ç‚¹æ•°: ${S.points} / ${S.floors}F / Ã—${S.mul.toFixed(2)}`, 14, 24);
    ctx.restore();
  }

  // =========================
  // ã‚²ãƒ¼ãƒ é€²è¡Œ
  // =========================
  function reset(){
    hideResultOverlay();

    S.playing = false;
    S.over = false;

    S.floors = 0;
    S.points = 0;
    S.mul = 1.0;
    S.comboPerfect = 0;

    S.lastTitle = "";
    S.lastSubtitle = "";
    S.lastRunAt = "";
    S.lastRunFloors = 0;
    S.lastRunPoints = 0;

    S.cameraY = 0;
    S.dir = 1;

    spawnBase();
    spawnCurrent();

    setHUD();
    draw();
  }

  function start(){
    if (S.over) reset();
    S.playing = true;
    setHUD();
  }

  function levelSpeed(){
    const base = CONF.speedBase + S.level * CONF.speedPerLevel;
    const mul = (S.curr && S.curr.speedMul) ? S.curr.speedMul : 1;
    return base * mul;
  }

  function endRun(){
    S.lastRunFloors = S.floors;
    S.lastRunPoints = S.points;

    const t = getTakoyakiTitle(S.floors);
    S.lastTitle = t.title;
    S.lastSubtitle = t.sub;

    if (S.points > S.bestPoints){
      S.bestPoints = S.points;
      saveBestPoints(S.bestPoints);
    }

    setResultDatetime();
    setHUD();
    showResultOverlay();
  }

  function gameOver(){
    S.over = true;
    S.playing = false;
    endRun();
  }

  function drop(){
    if (!S.curr || S.over) return;

    const prev = S.blocks[S.blocks.length - 1];
    const curr = S.curr;

    const overlapLeft  = Math.max(prev.x, curr.x);
    const overlapRight = Math.min(prev.x + prev.width, curr.x + curr.width);
    const overlapW = overlapRight - overlapLeft;

    if (overlapW <= 0){
      gameOver();
      return;
    }

    const diff = Math.abs(curr.x - prev.x);
    const perfectRange = CONF.perfectPx + (curr.perfectPlus || 0);
    const isPerfect = diff <= perfectRange;

    // ã€Œè¿‘ã„ã€åˆ¤å®šï¼ˆPERFECTã§ã¯ãªã„ãŒä¸Šæ‰‹ã„ï¼‰
    const nearPerfect = (!isPerfect && diff <= perfectRange * 2);

    const willShrink = overlapW < curr.width;

    // è™¹ä¼èª¬ï¼š1å›ã ã‘å‰Šã‚Œãªã„ä¿é™º
    if (curr.insurance && willShrink){
      curr.x = overlapLeft;
      curr.insurance = false;
      showToast("ğŸŒˆ ã‚»ãƒ¼ãƒ•ï¼");
    } else if (isPerfect){
      curr.x = prev.x;
      curr.width = prev.width;
      showToast(`PERFECT! Ã—${(S.comboPerfect+1)}`);
    } else {
      curr.x = overlapLeft;
      curr.width = overlapW;
    }

    // ç¢ºå®š
    pushConfirmedBlock(curr);
    S.curr = null;

    // âœ… æ®µæ•°æ›´æ–°
    S.level++;
    S.floors = Math.max(0, S.allBlocks.length - 1);

    // âœ… ã‚¹ã‚³ã‚¢åŠ ç®—ï¼ˆã“ã“ãŒæœ¬é¡Œï¼‰
    const base = getBaseScore(S.floors);
    const elapsed = performance.now() - (curr.spawnedAt || performance.now());
    const speedBonus = getSpeedBonus(elapsed);

    if (isPerfect){
      S.comboPerfect++;
      // PERFECTã§å€ç‡ãŒè‚²ã¤ï¼ˆÃ—1.30 â†’ +0.05ãšã¤ä¸Šæ˜‡ï¼‰
      S.mul = clampMul(CONF.PERFECT_MUL + S.comboPerfect * CONF.COMBO_MUL_ADD);
    } else if (nearPerfect){
      S.comboPerfect = 0;
      S.mul = clampMul(CONF.NEAR_MUL);
    } else {
      S.comboPerfect = 0;
      S.mul = 1.0;
    }

    const gained = Math.floor(base * S.mul) + speedBonus;
    S.points += gained;

    // ç‚¹ã®å†…è¨³ã‚’è»½ãè¦‹ã›ã‚‹ï¼ˆã†ã–ããªã‚‰ãªã„ç¯„å›²ï¼‰
    if (speedBonus > 0 && isPerfect) showToast(`+${gained}ï¼ˆæ—©Ã—PERFECTï¼‰`);
    else if (isPerfect) showToast(`+${gained}ï¼ˆÃ—${S.mul.toFixed(2)}ï¼‰`);
    else if (speedBonus > 0) showToast(`+${gained}ï¼ˆæ—©æŠ¼ã—ï¼‰`);

    // ãƒ™ã‚¹ãƒˆæ›´æ–°ï¼ˆç‚¹æ•°ï¼‰
    if (S.points > S.bestPoints){
      S.bestPoints = S.points;
      saveBestPoints(S.bestPoints);
    }

    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šï¼ˆå¹…ãŒé™ç•Œï¼‰
    if (curr.width < CONF.minWidth){
      gameOver();
      return;
    }

    spawnCurrent();
    setHUD();
  }

  function update(){
    if (S.playing && !S.over && S.curr){
      const sp = levelSpeed();
      S.curr.x += sp * S.dir;

      const minX = CONF.marginX;
      const maxX = CONF.canvasW - CONF.marginX - S.curr.width;

      if (S.curr.x <= minX){
        S.curr.x = minX;
        S.dir = 1;
      } else if (S.curr.x >= maxX){
        S.curr.x = maxX;
        S.dir = -1;
      }
    }

    if (!S.over) updateCamera();
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // =========================
  // å…¥åŠ›
  // =========================
  cv.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    if (!S.playing) start();
    else drop();
  }, { passive:false });

  stopBtn.addEventListener("click", () => {
    if (!S.playing) start();
    else drop();
  });

  restartBtn.addEventListener("click", reset);

  // =========================
  // åˆæœŸåŒ–
  // =========================
  loadImages().then(() => {
    reset();
    loop();
  });

})();
</script>


</body>
</html>
